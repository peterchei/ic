<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AgentMigrationStateService">
    <option name="migrationStatus" value="COMPLETED" />
  </component>
  <component name="Ask2AgentMigrationStateService">
    <option name="migrationStatus" value="COMPLETED" />
  </component>
  <component name="AskMigrationStateService">
    <option name="migrationStatus" value="COMPLETED" />
  </component>
  <component name="CompilerConfiguration">
    <resourceExtensions>
      <entry name=".+\.(properties|xml|html|dtd|tld)" />
      <entry name=".+\.(gif|png|jpeg|jpg)" />
    </resourceExtensions>
    <wildcardResourcePatterns>
      <entry name="!?*.java" />
      <entry name="!?*.groovy" />
    </wildcardResourcePatterns>
    <bytecodeTargetLevel>
      <module name="ic" target="21" />
      <module name="ic.main" target="21" />
      <module name="ic.test" target="21" />
      <module name="ic_main" target="1.8" />
      <module name="ic_test" target="1.8" />
    </bytecodeTargetLevel>
  </component>
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/ic/core/ChartScreen.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/ic/core/ChartScreen.java" />
              <option name="originalContent" value="package com.ic.core;&#10;&#10;import com.ic.data.*;&#10;import com.ic.util.FormatUtil;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.Point;&#10;import java.awt.event.MouseEvent;&#10;import java.awt.event.MouseListener;&#10;import java.awt.event.MouseMotionListener;&#10;import java.io.Serial;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Vector;&#10;import java.util.logging.Logger;&#10;&#10;public class ChartScreen extends JPanel implements MouseListener, MouseMotionListener {&#10;&#10;  public static final int NONE = 0;&#10;  public static final int LOADING = 1;&#10;  public static final int STARTED = 2;&#10;  private static final Logger log = Logger.getLogger(ChartScreen.class.getName());&#10;  @Serial&#10;  private static final long serialVersionUID = -6984851432299222149L;&#10;  private final String[][] lbArray = {{&quot;None&quot;, &quot;ç„¡&quot;} // 0&#10;    , {&quot;Simple Moving Average&quot;, &quot;\u7c21\u55ae\u79fb\u52d5\u5e73\u5747\u7dda&quot;} // 1&#10;    , {&quot;Weighted Moving Average&quot;, &quot;\u52a0\u6b0a\u79fb\u52d5\u5e73\u5747\u7dda&quot;} // 2&#10;    , {&quot;Exponential Moving Average&quot;, &quot;\u6307\u6578\u79fb\u52d5\u5e73\u5747\u7dda&quot;} // 3&#10;    , {&quot;Bollinger Bands&quot;, &quot;\u4fdd\u6b77\u52a0\u901a\u9053&quot;} // 4&#10;    , {&quot;Open&quot;, &quot;\u958b\u5e02&quot;} // 5&#10;    , {&quot;Close&quot;, &quot;\u6536\u5e02&quot;} // 6&#10;    , {&quot;High&quot;, &quot;\u6700\u9ad8&quot;} // 7&#10;    , {&quot;Low&quot;, &quot;\u6700\u4f4e&quot;} // 8&#10;    , {&quot;Volume&quot;, &quot;\u6210\u4ea4&quot;}// \u91cf&quot;} //9&#10;    , {&quot;RSI&quot;, &quot;RSI&quot; } //10&#10;    , {&quot;STC&quot;, &quot;STC&quot; } // 11&#10;    , {&quot;EMA&quot;, &quot;EMA&quot;} // 12&#10;    , {&quot;WMA&quot;, &quot;WMA&quot;} // 13&#10;    , {&quot;SMA&quot;, &quot;SMA&quot;} // 14&#10;    , {&quot;Date&quot;, &quot;\u671f\u9593&quot;} // 15&#10;    , {&quot;Time&quot;, &quot;\u671f\u9593&quot;} // 16&#10;    , {&quot;Relative Strength Index&quot;, &quot;\u76f8\u5c0d\ufffd\u5f31\u6307\u6578&quot;} // 17&#10;    , {&quot;Stochastics&quot;, &quot;\u96a8\u6a5f\u6307\u6578&quot;} // 18&#10;    , {&quot;On Balance Volume&quot;, &quot;\u6210\u4ea4\u91cf\u5e73 \u6307\u6578&quot;} // 19&#10;    , {&quot;Moving Average Convergence Divergence&quot;, &quot;\u79fb\u52d5\u5e73\u5747\u7dda\u532f\u805a\u80cc\u99b3\u6307\u6a19&quot;} // 20&#10;    , {&quot;William %R&quot;, &quot;\u5a01\u5ec9\u6307\u6a19&quot;} // 21&#10;    , {&quot;Deviation&quot;, &quot;Deviation&quot;} // 22&#10;    , {&quot;Date Reference&quot;, &quot;Date Reference&quot;} // 23&#10;    , {&quot;Time Reference&quot;, &quot;Time Reference&quot;} // 24&#10;  };&#10;  // Define of Resolution and display information&#10;  private final int minResolution = 3;&#10;  private final int language = FConfig.constEnglish;&#10;  // A list of add ChartUIObject needed to plot to this screen.....&#10;  private final Vector chartObjects = new Vector();&#10;  public Image[] loadingBarImage = new Image[4];&#10;  // The screenImage for drawing....&#10;  private Image screenImage = null; // the chart image&#10;  private Image allscreenImage = null; // the full screen image&#10;  private Image moveCursorImage = null;&#10;  // Action Object to record and repersent all the action.&#10;  private ActionCommand actionCommand = new ActionCommand();&#10;  private int screenState = STARTED;&#10;  private boolean isUpdatingBaseScreen = false; // check isUpdatingBaseScreen&#10;  // or not.&#10;  private Color gridColor;&#10;  /// The space of top, left, right and bottom in pixels.&#10;  private int topSpace = 20;&#10;  private int leftSpace = 40;&#10;  private int rightSpace = 20;&#10;  private int bottomSpace = 30;&#10;  // The maximun number of point that the chart have....&#10;  private int maxNumberOfChartPoint = 0;&#10;  private int loadingBarIndex = 0;&#10;  private int resolution = 3; // must be &lt; 4 pixels per point.&#10;  private int startDisplayIndex = 0;&#10;  private int endDisplayIndex = 0;&#10;  private ScreenActionListener screenActionListener = null;&#10;  private boolean IsWatching = false;&#10;  private int watchingPoint = 0;&#10;&#10;  public ChartScreen(int TOPSpace, int BOTTOMSpace, int LEFTSpace, int RIGHTSpace) {&#10;    topSpace = TOPSpace;&#10;    bottomSpace = BOTTOMSpace;&#10;    leftSpace = LEFTSpace;&#10;    rightSpace = RIGHTSpace;&#10;&#10;    moveCursorImage = new ImageIcon(getClass().getResource(&quot;/hand.png&quot;)).getImage();&#10;    try {&#10;      addMouseListener(this);&#10;      addMouseMotionListener(this);&#10;      init();&#10;    } catch (Exception e) {&#10;      log.warning(e.getMessage());&#10;    }&#10;&#10;  }&#10;&#10;  private ChartScreen() {&#10;    try {&#10;      addMouseListener(this);&#10;      addMouseMotionListener(this);&#10;      init();&#10;    } catch (Exception e) {&#10;      log.warning(e.getMessage());&#10;    }&#10;  }&#10;&#10;  public int getScreenState() {&#10;    return screenState;&#10;  }&#10;&#10;  public void setScreenState(int ss) {&#10;    screenState = ss;&#10;    this.repaint();&#10;  }&#10;&#10;  public ActionCommand getActionCommand() {&#10;    return actionCommand;&#10;  }&#10;&#10;  public void setActionCommand(ActionCommand actionCommand) {&#10;    this.actionCommand = actionCommand;&#10;  }&#10;&#10;  // get the chart given the key.&#10;  public ChartItem getChart(String key) {&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem pchart = (ChartItem) chartObjects.elementAt(i);&#10;      if (pchart.getKey().equals(key)) {&#10;        return pchart;&#10;      }&#10;    }&#10;    return null;&#10;  }&#10;&#10;  public ActionCommand getAction() {&#10;    return actionCommand;&#10;  }&#10;&#10;  // add a chart to this screen&#10;  public void addChart(ChartItem newChart) {&#10;    int tempNumb = 0;&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;      if (cchart.getKey().equals(newChart.getKey())) {&#10;        chartObjects.removeElement(cchart);&#10;      }&#10;    }&#10;    chartObjects.addElement(newChart);&#10;    // get the max Number Of Chart Point......&#10;&#10;    for (int i = 0; i &lt; this.chartObjects.size(); i++) {&#10;      ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;      if (tempNumb == 0 || cchart.getChartData().getData().size() &lt; tempNumb) {&#10;        tempNumb = cchart.getChartData().getData().size();&#10;      }&#10;    }&#10;    maxNumberOfChartPoint = tempNumb;&#10;  }&#10;&#10;  // get the LowerBound and UpperBound of the L or R chart&#10;  private FBound getAxisBound(AxisType axisBarType) {&#10;&#10;    double bStockMax = -1000000f;&#10;    double bStockMin = 1000000f;&#10;&#10;    float bPercentageMax = 0;&#10;    float bPercentageMin = 100;&#10;&#10;    float bMACDMax = -1000000f;&#10;    float bMACDMin = 1000000f;&#10;&#10;    float bOBVMax = -10000f;&#10;    float bOBVMin = 100000f;&#10;&#10;    double bVolumeMax = 0;&#10;    double bVolumeMin = 0;&#10;&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;      if (cchart.getAxisBar() == axisBarType) {&#10;        if (cchart.getChartType() == ChartType.BAR || cchart.getChartType() == ChartType.CANDLE&#10;          || cchart.getChartType() == ChartType.LINE) {&#10;          double Max = cchart.getChartData().getMaximum(startDisplayIndex, endDisplayIndex, &quot;STOCK&quot;);&#10;          if (Max &gt; bStockMax) {&#10;            bStockMax = Max;&#10;          }&#10;          double Min = cchart.getChartData().getMinimum(startDisplayIndex, endDisplayIndex, &quot;STOCK&quot;);&#10;          if (Min &lt; bStockMin) {&#10;            bStockMin = Min;&#10;          }&#10;        }&#10;&#10;        if (cchart.getChartType() == ChartType.VOLUME) {&#10;          double Max = cchart.getChartData().getMaximumVolume(startDisplayIndex, endDisplayIndex);&#10;          if (Max &gt; bVolumeMax) {&#10;            bVolumeMax = Max;&#10;          }&#10;        }&#10;      }&#10;&#10;      if (cchart.getChartType() == ChartType.PERCENTAGE) {&#10;        float Max = (float) cchart.getChartData().getMaximum(startDisplayIndex, endDisplayIndex, &quot;PERCENTAGE&quot;);&#10;        if (Max &gt; bPercentageMax) {&#10;          bPercentageMax = Max;&#10;        }&#10;        float Min = (float) cchart.getChartData().getMinimum(startDisplayIndex, endDisplayIndex, &quot;PERCENTAGE&quot;);&#10;        if (Min &lt; bPercentageMin) {&#10;          bPercentageMin = Min;&#10;        }&#10;      }&#10;&#10;      if (cchart.getChartType() == ChartType.SIMPLE_MOVING_AVERAGE&#10;        || cchart.getChartType() == ChartType.WEIGHTED_MOVING_AVERAGE&#10;        || cchart.getChartType() == ChartType.EXPONENTIAL_MOVING_AVERAGE) {&#10;        double Max = cchart.getChartData().getMaximum(startDisplayIndex, endDisplayIndex, &quot;STOCK&quot;);&#10;        if (Max &gt; bStockMax) {&#10;          bStockMax = Max;&#10;        }&#10;        double Min = cchart.getChartData().getMinimum(startDisplayIndex, endDisplayIndex, &quot;STOCK&quot;);&#10;        if (Min &lt; bStockMin) {&#10;          bStockMin = Min;&#10;        }&#10;      }&#10;&#10;      if (cchart.getChartType() == ChartType.BOLLINGERBAND) {&#10;        double Max = cchart.getChartData().getMaximum(startDisplayIndex, endDisplayIndex, &quot;STOCK&quot;);&#10;        if (Max &gt; bStockMax) {&#10;          bStockMax = Max;&#10;        }&#10;        double Min = cchart.getChartData().getMinimum(startDisplayIndex, endDisplayIndex, &quot;STOCK&quot;);&#10;        if (Min &lt; bStockMin) {&#10;          bStockMin = Min;&#10;        }&#10;      }&#10;&#10;      if (cchart.getChartType() == ChartType.MACD) {&#10;        double Max = cchart.getChartData().getMaximum(startDisplayIndex, endDisplayIndex, &quot;MACD&quot;);&#10;        if (Max &gt; bStockMax) {&#10;          bMACDMax = (float) Max;&#10;        }&#10;        double Min = cchart.getChartData().getMinimum(startDisplayIndex, endDisplayIndex, &quot;MACD&quot;);&#10;        if (Min &lt; bStockMin) {&#10;          bMACDMin = (float) Min;&#10;        }&#10;      }&#10;&#10;      if (cchart.getChartType() == ChartType.OBV) {&#10;        double Max = cchart.getChartData().getMaximum(startDisplayIndex, endDisplayIndex, &quot;OBV&quot;);&#10;        if (Max &gt; bStockMax) {&#10;          bOBVMax = (float) Max;&#10;        }&#10;        double Min = cchart.getChartData().getMinimum(startDisplayIndex, endDisplayIndex, &quot;OBV&quot;);&#10;        if (Min &lt; bStockMin) {&#10;          bOBVMin = (float) Min;&#10;        }&#10;      }&#10;    }&#10;&#10;    FBound newBound = new FBound();&#10;&#10;    double ss = (bStockMax - bStockMin) * 0.1f;&#10;    newBound.setLowerStockBound(bStockMin - ss);&#10;    newBound.setUpperStockBound(bStockMax + ss);&#10;    newBound.setLowerVolumeBound(0);&#10;    newBound.setUpperVolumeBound(bVolumeMax + 5);&#10;    ss = (bPercentageMax - bPercentageMin) * 0.1f;&#10;    newBound.setLowerPercentageBound(bPercentageMin - (float) ss);&#10;    newBound.setUpperPercentageBound(bPercentageMax + (float) ss);&#10;    ss = (bMACDMax - bMACDMin) * 0.1f;&#10;    newBound.setLowerMACDBound(bMACDMin - (float) ss);&#10;    newBound.setUpperMACDBound(bMACDMax + (float) ss);&#10;    newBound.setLowerOBVBound((int) bOBVMin);&#10;    newBound.setUpperOBVBound((int) bOBVMax);&#10;&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;      if (cchart.getAxisBar() == axisBarType) {&#10;        cchart.setChartBound(newBound);&#10;      }&#10;      if (cchart.getChartType() == ChartType.PERCENTAGE &amp;&amp; axisBarType == AxisType.LEFTAXIS) {&#10;        cchart.setChartBound(newBound);&#10;      }&#10;    }&#10;    return newBound;&#10;  }&#10;&#10;  // function to initScreen, it should be called once in applet.start function&#10;  // in order to fix UI bug.&#10;  public void initScreen() {&#10;    if (getSize().width &gt; 0 &amp;&amp; getSize().height &gt; 0) {&#10;      if (getScreenImage() == null) {&#10;        setScreenImage(createImage(getSize().width, getSize().height));&#10;      }&#10;      if (getAllScreenImage() == null) {&#10;        setAllScreenImage(createImage(getSize().width, getSize().height));&#10;      }&#10;&#10;      if (loadingBarImage[0] == null) {&#10;        loadingBarImage[0] = new ImageIcon(getClass().getResource(&quot;/LoadingBar0.png&quot;)).getImage();&#10;        loadingBarImage[1] = new ImageIcon(getClass().getResource(&quot;/LoadingBar1.png&quot;)).getImage();&#10;        loadingBarImage[2] = new ImageIcon(getClass().getResource(&quot;/LoadingBar2.png&quot;)).getImage();&#10;        loadingBarImage[3] = new ImageIcon(getClass().getResource(&quot;/LoadingBar3.png&quot;)).getImage();&#10;      }&#10;    }&#10;  }&#10;&#10;  public int getStartDisplayIndex() {&#10;    return startDisplayIndex;&#10;  }&#10;&#10;  public int getEndDisplayIndex() {&#10;    return endDisplayIndex;&#10;  }&#10;&#10;  // remove a chart from this screen given the name&#10;  public boolean removeChart(String key) {&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem chartobj = (ChartItem) chartObjects.elementAt(i);&#10;      if (chartobj.getKey().equals(key)) {&#10;        chartObjects.removeElementAt(i);&#10;        return true;&#10;      }&#10;    }&#10;    return false;&#10;  }&#10;&#10;  // remove a chart from this screen given the name&#10;  public boolean removeChart(int code) {&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem chartobj = (ChartItem) chartObjects.elementAt(i);&#10;      if (chartobj.getChartData().getCode().equals(code)) {&#10;        chartObjects.removeElementAt(i);&#10;      }&#10;    }&#10;&#10;    return true;&#10;  }&#10;&#10;  public void removeChartsByType(ChartType cType) {&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem chartobj = (ChartItem) chartObjects.elementAt(i);&#10;      if (chartobj.getChartType() == cType) {&#10;        chartObjects.removeElementAt(i);&#10;        i = -1;&#10;      }&#10;    }&#10;  }&#10;&#10;  boolean isWithinChartRegion(int x, int y) {&#10;    if (x &gt;= leftSpace &amp;&amp; x &lt;= (getXAxisWidth() + leftSpace + 2)) {&#10;      return y &gt;= topSpace &amp;&amp; y &lt;= (getYAxisWidth() + topSpace);&#10;    }&#10;    return false;&#10;  }&#10;&#10;  int getXAxisWidth() {&#10;    return getSize().width - leftSpace - rightSpace;&#10;  }&#10;&#10;  int getYAxisWidth() {&#10;    return getSize().height - topSpace - bottomSpace;&#10;  }&#10;&#10;  private void init() throws Exception {&#10;    this.setBackground(FConfig.ScreenBackground);&#10;    this.setLayout(null);&#10;  }&#10;&#10;  @Override&#10;  public void setBounds(int x, int y, int w, int h) {&#10;&#10;    if (h == 0) {&#10;      return;&#10;    }&#10;    Image newImage1 = null;&#10;    Image newImage2 = null;&#10;    try {&#10;      if (getScreenImage() != null&#10;        &amp;&amp; (getScreenImage().getHeight(this) != h || getScreenImage().getWidth(this) != w)) {&#10;        newImage1 = createImage(w, h);&#10;        setScreenImage(newImage1);&#10;      }&#10;      if (getAllScreenImage() != null&#10;        &amp;&amp; (getAllScreenImage().getHeight(this) != h || getAllScreenImage().getWidth(this) != w)) {&#10;        newImage2 = createImage(w, h);&#10;        setAllScreenImage(newImage2);&#10;      }&#10;      super.setBounds(x, y, w, h);&#10;    } catch (Exception ee) {&#10;      log.warning(ee.getMessage());&#10;    }&#10;&#10;  }&#10;&#10;  public boolean zoom(int startIndex, int endIndex) {&#10;    // first, determine the new resolution.....&#10;    int numberOfpoints = endIndex - startIndex + 1;&#10;    float fpixelsperpoint = (float) (getXAxisWidth() - 2) / numberOfpoints;&#10;    resolution = (int) (fpixelsperpoint + 0.01d);&#10;&#10;    startDisplayIndex = startIndex;&#10;    endDisplayIndex = endIndex;&#10;&#10;    // update the Screen and notify to listener&#10;    this.updateBaseScreen();&#10;&#10;    // remove lines because of when using percentage..........&#10;    ChartItem ccchart = getLeftChart();&#10;    if (ccchart != null &amp;&amp; ccchart.getChartType() == ChartType.PERCENTAGE) {&#10;      actionCommand.getLineRecords().removeAllElements();&#10;      actionCommand.setGoldenPartitionLine(null);&#10;    }&#10;    this.repaint();&#10;    if (screenActionListener != null) {&#10;      screenActionListener.OnZoomCompleted(this, startDisplayIndex, endDisplayIndex);&#10;    }&#10;    return true;&#10;  }&#10;&#10;  public void watch(int watchPoint) {&#10;    // update the Screen and notify to listener&#10;    // getAction().setActionType(ActionCommand.ActionType.WATCH);&#10;    // this.updateBaseScreen();&#10;    IsWatching = true;&#10;    watchingPoint = watchPoint;&#10;    this.repaint();&#10;&#10;  }&#10;&#10;  // The function is used to plot the chart&#10;  @Override&#10;  public void update(Graphics g) {&#10;    paint(g);&#10;  }&#10;&#10;  @Override&#10;  public void paint(Graphics gg) {&#10;    if (isUpdatingBaseScreen) {&#10;      return;&#10;    }&#10;    if (getScreenImage() == null) {&#10;      setScreenImage(createImage(getSize().width, this.getSize().height));&#10;    }&#10;    if (getAllScreenImage() == null) {&#10;      setAllScreenImage(createImage(getSize().width, this.getSize().height));&#10;    }&#10;&#10;    Graphics g = getAllScreenImage().getGraphics();&#10;&#10;    // Enable anti-aliasing for professional smooth rendering&#10;    if (g instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) g;&#10;      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;      g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);&#10;      g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);&#10;      g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);&#10;    }&#10;    g.drawImage(getScreenImage(), 0, 0, getSize().width, getSize().height, this);&#10;    g.setColor(Color.black);&#10;    for (int i = 0; i &lt; actionCommand.getLineRecords().size(); i++) {&#10;      FLine fline = (FLine) actionCommand.getLineRecords().elementAt(i);&#10;      if (FLine.isFixedLine()) {&#10;        g.setColor(Color.black);&#10;        g.drawLine(fline.getPoint1().x, fline.getPoint1().y, fline.getPoint2().x, fline.getPoint2().y);&#10;      } else {&#10;        g.setColor(Color.black);&#10;        int x1 = getScreenXPositionFromPoint(fline.getIndex1());&#10;        int x2 = getScreenXPositionFromPoint(fline.getIndex2());&#10;        int y1, y2;&#10;        ChartItem cchart = getLeftChart();&#10;        if (cchart != null) {&#10;          double Max = cchart.getUpperBound();&#10;          double Min = cchart.getLowerBound();&#10;          y1 = getScreenYPosition(fline.getValue1(), Max, Min);&#10;          y2 = getScreenYPosition(fline.getValue2(), Max, Min);&#10;          g.drawLine(x1, y1, x2, y2);&#10;        }&#10;      }&#10;    }&#10;&#10;    for (int i = 0; i &lt; actionCommand.getTextRecords().size(); i++) {&#10;      FText record = (FText) actionCommand.getTextRecords().elementAt(i);&#10;&#10;      g.setColor(Color.black);&#10;      ChartItem cchart = getLeftChart();&#10;      if (cchart != null) {&#10;        double Max = cchart.getUpperBound();&#10;        double Min = cchart.getLowerBound();&#10;        int y1 = getScreenYPosition(record.getYValue(), Max, Min);&#10;        int x1 = getScreenXPositionFromPoint(record.getXIndex());&#10;        g.drawString(record.getText(), x1, y1);&#10;      }&#10;&#10;    }&#10;&#10;    // if we are not process GOLDENPAERTITION and we have one need to draw&#10;    if (actionCommand.getActionType() != ActionType.GOLDEN_PARTITION || !actionCommand.isProcessing()) {&#10;      if (actionCommand.getGoldenPartitionLine() != null) {&#10;        int MaxY = 0, MinY = 0;&#10;        int x1;&#10;        if (FLine.isFixedLine()) {&#10;          MaxY = Math.max(actionCommand.getGoldenPartitionLine().getPoint1().y,&#10;            actionCommand.getGoldenPartitionLine().getPoint2().y);&#10;          MinY = Math.min(actionCommand.getGoldenPartitionLine().getPoint1().y,&#10;            actionCommand.getGoldenPartitionLine().getPoint2().y);&#10;          x1 = actionCommand.getGoldenPartitionLine().getPoint1().x;&#10;&#10;&#10;        } else {&#10;          x1 = getScreenXPositionFromPoint(actionCommand.getGoldenPartitionLine().getIndex1());&#10;          int y1, y2;&#10;          ChartItem cchart = getLeftChart();&#10;          if (cchart != null) {&#10;            double Max = cchart.getUpperBound();&#10;            double Min = cchart.getLowerBound();&#10;            y1 = getScreenYPosition(actionCommand.getGoldenPartitionLine().getValue1(), Max, Min);&#10;            y2 = getScreenYPosition(actionCommand.getGoldenPartitionLine().getValue2(), Max, Min);&#10;            MaxY = Math.max(y1, y2);&#10;            MinY = Math.min(y1, y2);&#10;          }&#10;        }&#10;&#10;        int Y618 = (int) (MaxY - (MaxY - MinY) * 0.618f);&#10;        int Y50 = (int) (MaxY - (MaxY - MinY) * 0.50f);&#10;        int Y382 = (int) (MaxY - (MaxY - MinY) * 0.382);&#10;&#10;        g.drawString(&quot;0%&quot;, x1 + 2, MaxY - 1);&#10;        g.drawString(&quot;100%&quot;, x1 + 2, MinY - 1);&#10;        g.drawLine(x1, MaxY, leftSpace + getXAxisWidth(), MaxY);&#10;        g.drawLine(x1, MinY, leftSpace + getXAxisWidth(), MinY);&#10;        g.setColor(Color.red);&#10;        drawDotLine(g, x1, Y618, leftSpace + getXAxisWidth(), Y618);&#10;        drawDotLine(g, x1, Y50, leftSpace + getXAxisWidth(), Y50);&#10;        drawDotLine(g, x1, Y382, leftSpace + getXAxisWidth(), Y382);&#10;        g.setColor(Color.darkGray);&#10;        g.drawString(&quot;61.8%&quot;, x1 + 2, Y618 - 1);&#10;        g.drawString(&quot;50%&quot;, x1 + 2, Y50 - 1);&#10;        g.drawString(&quot;38.2%&quot;, x1 + 2, Y382 - 1);&#10;&#10;        ChartItem cchart = getLeftChart();&#10;        if (cchart != null) {&#10;          double UpperBound = cchart.getUpperBound();&#10;          double LowerBound = cchart.getLowerBound();&#10;          float v100 = (float) getYValueFromScreen(MinY, UpperBound, LowerBound);&#10;          float v618 = (float) getYValueFromScreen(Y618, UpperBound, LowerBound);&#10;          float v500 = (float) getYValueFromScreen(Y50, UpperBound, LowerBound);&#10;          float v382 = (float) getYValueFromScreen(Y382, UpperBound, LowerBound);&#10;          float v000 = (float) getYValueFromScreen(MaxY, UpperBound, LowerBound);&#10;          g.setColor(cchart.getFirstColor());&#10;          if (cchart.getChartType() == ChartType.PERCENTAGE) {&#10;            g.drawString(FormatUtil.format2DecimalPlace(v100) + &quot;%&quot;, x1 + 40, MinY - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v618) + &quot;%&quot;, x1 + 40, Y618 - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v500) + &quot;%&quot;, x1 + 40, Y50 - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v382) + &quot;%&quot;, x1 + 40, Y382 - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v000) + &quot;%&quot;, x1 + 40, MaxY - 1);&#10;          } else {&#10;            g.drawString(FormatUtil.format2DecimalPlace(v100), x1 + 40, MinY - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v618), x1 + 40, Y618 - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v500), x1 + 40, Y50 - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v382), x1 + 40, Y382 - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v000), x1 + 40, MaxY - 1);&#10;          }&#10;        }&#10;        cchart = getRightChart();&#10;        if (cchart != null) {&#10;          double UpperBound = cchart.getUpperBound();&#10;          double LowerBound = cchart.getLowerBound();&#10;          float v100 = (float) getYValueFromScreen(MinY, UpperBound, LowerBound);&#10;          float v618 = (float) getYValueFromScreen(Y618, UpperBound, LowerBound);&#10;          float v500 = (float) getYValueFromScreen(Y50, UpperBound, LowerBound);&#10;          float v382 = (float) getYValueFromScreen(Y382, UpperBound, LowerBound);&#10;          float v000 = (float) getYValueFromScreen(MaxY, UpperBound, LowerBound);&#10;          g.setColor(cchart.getFirstColor());&#10;&#10;          g.drawString(FormatUtil.format2DecimalPlace(v100), x1 + 80, MinY - 1);&#10;          g.drawString(FormatUtil.format2DecimalPlace(v618), x1 + 80, Y618 - 1);&#10;          g.drawString(FormatUtil.format2DecimalPlace(v500), x1 + 80, Y50 - 1);&#10;          g.drawString(FormatUtil.format2DecimalPlace(v382), x1 + 80, Y382 - 1);&#10;          g.drawString(FormatUtil.format2DecimalPlace(v000), x1 + 80, MaxY - 1);&#10;        }&#10;      }&#10;    }&#10;&#10;    /// process current action ..................................&#10;    if (this.screenState != LOADING) {&#10;      switch (actionCommand.getActionType()) {&#10;        //// ----------------------Response to Zoom Action&#10;        //// ------------------------------------------////////&#10;        case ZOOM_IN:&#10;          if (actionCommand.isProcessing()) {&#10;            Point opoint = new Point();&#10;            Point epoint = new Point();&#10;            opoint.x = Math.min(actionCommand.getStartMousePoint().x, actionCommand.getCurrentMousePoint().x);&#10;            opoint.y = Math.min(actionCommand.getStartMousePoint().y, actionCommand.getCurrentMousePoint().y);&#10;            epoint.x = Math.max(actionCommand.getStartMousePoint().x, actionCommand.getCurrentMousePoint().x);&#10;            epoint.y = Math.max(actionCommand.getStartMousePoint().y, actionCommand.getCurrentMousePoint().y);&#10;&#10;            if (opoint.y &lt; topSpace) {&#10;              opoint.y = topSpace + 1;&#10;            }&#10;            if (opoint.x &lt; leftSpace) {&#10;              opoint.x = leftSpace + 1;&#10;            }&#10;            if (epoint.y &gt; topSpace + getYAxisWidth()) {&#10;              epoint.y = topSpace + getYAxisWidth() - 1;&#10;            }&#10;            if (epoint.x &gt; leftSpace + getXAxisWidth()) {&#10;              epoint.x = leftSpace + getXAxisWidth() - 1;&#10;            }&#10;            g.drawRect(opoint.x, opoint.y, Math.abs(epoint.x - opoint.x), Math.abs(epoint.y - opoint.y));&#10;          }&#10;          break;&#10;&#10;        //// ----------------------Response to Watch Action&#10;        //// -----------------------------------------///////&#10;        case WATCH:&#10;          if (actionCommand.isProcessing() &amp;&amp; isWithinChartRegion(actionCommand.getCurrentMousePoint().x,&#10;            actionCommand.getCurrentMousePoint().y)) {&#10;            ChartItem cchart = getLeftChart();&#10;            if (cchart != null) {&#10;              g.setColor(FConfig.ToolBarColor);&#10;              g.drawLine(actionCommand.getCurrentMousePoint().x - 1, topSpace,&#10;                actionCommand.getCurrentMousePoint().x - 1, getHeight() - topSpace - bottomSpace);&#10;              drawWatchAction();&#10;            }&#10;          }&#10;          break;&#10;        //// ----------------------Response to INSERTLINE Action&#10;        //// ------------------------------------------////////&#10;        case INSERT_LINE:&#10;          // System.out.println(actionCommand.isProcessing);&#10;          if (actionCommand.isProcessing()) {&#10;            g.drawLine(actionCommand.getCurrentMousePoint().x, actionCommand.getCurrentMousePoint().y,&#10;              actionCommand.getStartMousePoint().x, actionCommand.getStartMousePoint().y);&#10;          }&#10;          break;&#10;        //// ----------------------Response to Insert Parallel Line Action&#10;        //// ------------------------------------------////////&#10;        case INSERT_PARALLEL_LINE:&#10;          // if (actionCommand.isProcessing == true &amp;&amp;&#10;          // isWithinChartRegion(actionCommand.currentMousePoint.x,actionCommand.currentMousePoint.y))&#10;          if (actionCommand.isProcessing()) {&#10;            FLine fline = (FLine) actionCommand.getLineRecords().lastElement();&#10;            Point rpoint = new Point(0, 0);&#10;            if (fline.getPoint1().x &lt; fline.getPoint2().x) {&#10;              rpoint.x = fline.getPoint1().x;&#10;              rpoint.y = fline.getPoint1().y;&#10;            } else {&#10;              rpoint.x = fline.getPoint2().x;&#10;              rpoint.y = fline.getPoint2().y;&#10;            }&#10;            int dx = +actionCommand.getCurrentMousePoint().x - rpoint.x;&#10;            int dy = +actionCommand.getCurrentMousePoint().y - rpoint.y;&#10;&#10;            g.drawLine(fline.getPoint1().x + dx, fline.getPoint1().y + dy, fline.getPoint2().x + dx,&#10;              fline.getPoint2().y + dy);&#10;          }&#10;          break;&#10;&#10;        //// ----------------------Response to Golden partition Action&#10;        //// ------------------------------------------////////&#10;        case GOLDEN_PARTITION:&#10;          // if (actionCommand.isProcessing == true &amp;&amp;&#10;          // isWithinChartRegion(actionCommand.currentMousePoint.x,actionCommand.currentMousePoint.y))&#10;          if (actionCommand.isProcessing()) {&#10;            int MaxY = Math.max(actionCommand.getStartMousePoint().y, actionCommand.getCurrentMousePoint().y);&#10;            int MinY = Math.min(actionCommand.getStartMousePoint().y, actionCommand.getCurrentMousePoint().y);&#10;&#10;            int Y618 = (int) (MaxY - (MaxY - MinY) * 0.618f);&#10;            int Y50 = (int) (MaxY - (MaxY - MinY) * 0.50f);&#10;            int Y382 = (int) (MaxY - (MaxY - MinY) * 0.382);&#10;            g.drawString(&quot;100%&quot;, actionCommand.getStartMousePoint().x + 2, MinY - 1);&#10;            g.drawLine(actionCommand.getStartMousePoint().x, MaxY, leftSpace + getXAxisWidth(), MaxY);&#10;            g.drawString(&quot;0%&quot;, actionCommand.getStartMousePoint().x + 2, MaxY - 1);&#10;            g.drawLine(actionCommand.getStartMousePoint().x, MinY, leftSpace + getXAxisWidth(), MinY);&#10;            g.setColor(Color.red);&#10;            drawDotLine(g, actionCommand.getStartMousePoint().x, Y618, leftSpace + getXAxisWidth(), Y618);&#10;            drawDotLine(g, actionCommand.getStartMousePoint().x, Y50, leftSpace + getXAxisWidth(), Y50);&#10;            drawDotLine(g, actionCommand.getStartMousePoint().x, Y382, leftSpace + getXAxisWidth(), Y382);&#10;            g.setColor(Color.darkGray);&#10;            g.drawString(&quot;38.2%&quot;, actionCommand.getStartMousePoint().x + 2, Y382 - 1);&#10;            g.drawString(&quot;50%&quot;, actionCommand.getStartMousePoint().x + 2, Y50 - 1);&#10;            g.drawString(&quot;61.8%&quot;, actionCommand.getStartMousePoint().x + 2, Y618 - 1);&#10;&#10;            ChartItem cchart = getLeftChart();&#10;            if (cchart != null) {&#10;              double UpperBound = cchart.getUpperBound();&#10;              double LowerBound = cchart.getLowerBound();&#10;              float v100 = (float) getYValueFromScreen(MinY, UpperBound, LowerBound);&#10;              float v618 = (float) getYValueFromScreen(Y618, UpperBound, LowerBound);&#10;              float v500 = (float) getYValueFromScreen(Y50, UpperBound, LowerBound);&#10;              float v382 = (float) getYValueFromScreen(Y382, UpperBound, LowerBound);&#10;              float v000 = (float) getYValueFromScreen(MaxY, UpperBound, LowerBound);&#10;              g.setColor(cchart.getFirstColor());&#10;              if (cchart.getChartType() == ChartType.PERCENTAGE) {&#10;                g.drawString(FormatUtil.format2DecimalPlace(v100) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 40, MinY - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v618) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 40, Y618 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v500) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 40, Y50 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v382) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 40, Y382 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v000) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 40, MaxY - 1);&#10;              } else {&#10;                g.drawString(FormatUtil.format2DecimalPlace(v100),&#10;                  actionCommand.getStartMousePoint().x + 40, MinY - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v618),&#10;                  actionCommand.getStartMousePoint().x + 40, Y618 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v500),&#10;                  actionCommand.getStartMousePoint().x + 40, Y50 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v382),&#10;                  actionCommand.getStartMousePoint().x + 40, Y382 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v000),&#10;                  actionCommand.getStartMousePoint().x + 40, MaxY - 1);&#10;              }&#10;            }&#10;&#10;            cchart = getRightChart();&#10;            if (cchart != null) {&#10;              double UpperBound = cchart.getUpperBound();&#10;              double LowerBound = cchart.getLowerBound();&#10;              float v100 = (float) getYValueFromScreen(MinY, UpperBound, LowerBound);&#10;              float v618 = (float) getYValueFromScreen(Y618, UpperBound, LowerBound);&#10;              float v500 = (float) getYValueFromScreen(Y50, UpperBound, LowerBound);&#10;              float v382 = (float) getYValueFromScreen(Y382, UpperBound, LowerBound);&#10;              float v000 = (float) getYValueFromScreen(MaxY, UpperBound, LowerBound);&#10;              g.setColor(cchart.getFirstColor());&#10;              if (cchart.getChartType() == ChartType.PERCENTAGE) {&#10;                g.drawString(FormatUtil.format2DecimalPlace(v100) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 80, MinY - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v618) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 80, Y618 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v500) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 80, Y50 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v382) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 80, Y382 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v000) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 80, MaxY - 1);&#10;              } else {&#10;                g.drawString(FormatUtil.format2DecimalPlace(v100),&#10;                  actionCommand.getStartMousePoint().x + 80, MinY - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v618),&#10;                  actionCommand.getStartMousePoint().x + 80, Y618 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v500),&#10;                  actionCommand.getStartMousePoint().x + 80, Y50 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v382),&#10;                  actionCommand.getStartMousePoint().x + 80, Y382 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v000),&#10;                  actionCommand.getStartMousePoint().x + 80, MaxY - 1);&#10;              }&#10;            }&#10;          }&#10;          break;&#10;&#10;      }&#10;    }&#10;&#10;    /// Plot V line when watching&#10;    if (IsWatching) {&#10;      if (watchingPoint &gt; 0) {&#10;        g.setColor(FConfig.ToolBarColor);&#10;        g.drawLine(watchingPoint, topSpace, watchingPoint, getHeight() - topSpace - bottomSpace);&#10;        actionCommand.setCurrentMousePoint(new com.ic.data.Point(watchingPoint, 0));&#10;        plotWatchTable(getLeftChart());&#10;      }&#10;      // IsWatching =false;&#10;    }&#10;    ////// plot the&#10;    ////// Axis/////////////////////////////////////////////////////////////////////////&#10;    plotAxis(true);&#10;    drawCompareTable();&#10;    // plotCloseButton();&#10;    // draw the buffered image to the screen&#10;    // /////////////////////////////////////////////////&#10;&#10;    if (this.screenState == LOADING) {&#10;      plotLoading();&#10;    }&#10;    gg.drawImage(getAllScreenImage(), 0, 0, getSize().width, getSize().height, this);&#10;  }&#10;&#10;  private void plotWatchTable(ChartItem cchart) {&#10;    Graphics g = getAllScreenImage().getGraphics();&#10;    if (cchart != null) {&#10;      int index = getPointIndexFromScreen(actionCommand.getCurrentMousePoint().x);&#10;      StockData fpoint = cchart.getChartData().getData().get(index);&#10;      AnalyticalResult fTApoint = null;&#10;      if (cchart.getChartData().getAnalyticalResults().size() &gt; index) {&#10;        fTApoint = cchart.getChartData().getAnalyticalResults().get(index);&#10;      }&#10;&#10;      String pDate = new SimpleDateFormat(&quot;MMM-dd&quot;).format(fpoint.getDate());&#10;      StringBuilder sb = new StringBuilder(200);&#10;      sb.append(pDate).append(&quot; &quot;);&#10;      int x = leftSpace + 5;&#10;      int y = this.getHeight() - bottomSpace - 3;&#10;      g.setColor(FConfig.ToolBarColor);&#10;      g.fill3DRect(x - 2, y - 16, getWidth() - 6 - rightSpace - leftSpace, 18, true);&#10;      g.setColor(Color.WHITE);&#10;      switch (cchart.getChartType()) {&#10;        case PERCENTAGE:&#10;          break;&#10;        case MACD:&#10;          sb.append(&quot;MACD1:&quot; + FormatUtil.format3DecimalPlace(fTApoint.getMACD1()));&#10;          sb.append(&quot;, MACD2: &quot; + FormatUtil.format3DecimalPlace(fTApoint.getMACD2()));&#10;          sb.append(&quot;, Diff: &quot; + FormatUtil.format3DecimalPlace(fTApoint.getMACDdiff()));&#10;          g.drawString(sb.toString(), x, y);&#10;          break;&#10;&#10;        case RSI:&#10;          sb.append(&quot;RSI:&quot;).append(fTApoint.getRSI());&#10;          g.drawString(sb.toString(), x, y);&#10;          break;&#10;&#10;        case STC:&#10;          sb.append(&quot;%K:&quot;).append(FormatUtil.format3DecimalPlace(fTApoint.getK()));&#10;          sb.append(&quot; %D:&quot;).append(FormatUtil.format3DecimalPlace(fTApoint.getD()));&#10;          g.drawString(sb.toString(), x, y);&#10;          break;&#10;&#10;        case OBV:&#10;          sb.append(&quot;OBV:&quot;).append(fTApoint.getOBV());&#10;          g.drawString(sb.toString(), x, y);&#10;          break;&#10;&#10;        case WILLIAM_R:&#10;          sb.append(&quot;William %R:&quot;).append(fTApoint.getR());&#10;          g.drawString(sb.toString(), x, y);&#10;          break;&#10;&#10;        case VOLUME:&#10;          sb.append(&quot;Volume:&quot;).append(fpoint.getVolume());&#10;          g.drawString(sb.toString(), x, y);&#10;          break;&#10;&#10;        case CANDLE:&#10;        case LINE:&#10;        case BAR:&#10;&#10;          sb.append(&quot;OPEN:&quot;).append(FormatUtil.format3DecimalPlace(fpoint.getOpen())).append(&quot;, &quot;);&#10;          sb.append(&quot;CLOSE:&quot;).append(FormatUtil.format3DecimalPlace(fpoint.getClose())).append(&quot;, &quot;);&#10;          sb.append(&quot;HIGH:&quot;).append(FormatUtil.format3DecimalPlace(fpoint.getMaximum())).append(&quot;, &quot;);&#10;          sb.append(&quot;LOW:&quot;).append(FormatUtil.format3DecimalPlace(fpoint.getMinimum())).append(&quot;, &quot;);&#10;          sb.append(&quot;VOL:&quot;).append(FormatUtil.formatInteger(fpoint.getVolume()));&#10;          g.drawString(sb.toString(), x, y);&#10;          break;&#10;      }&#10;&#10;    }&#10;&#10;  }&#10;&#10;  private void drawWatchAction() {&#10;&#10;    int indexPoint = getPointIndexFromScreen(actionCommand.getCurrentMousePoint().x);&#10;    if (indexPoint &lt; startDisplayIndex || indexPoint &gt; endDisplayIndex) {&#10;      return;&#10;    }&#10;&#10;    ChartItem leftChart = getLeftChart();&#10;    ChartItem rightChart = getRightChart();&#10;&#10;    // draw the value where the mouse pointed.&#10;    double pointedValue = this.getYValueFromScreen(actionCommand.getCurrentMousePoint().y,&#10;      leftChart.getUpperBound(), leftChart.getLowerBound());&#10;    Graphics g = getAllScreenImage().getGraphics();&#10;    g.setColor(FConfig.WatchLabelColor);&#10;    g.setFont(new Font(&quot;default&quot;, 1, 14));&#10;    if (leftChart.getChartType() == ChartType.VOLUME) {&#10;      g.drawString(String.valueOf((int) (pointedValue)), actionCommand.getCurrentMousePoint().x + 1,&#10;        actionCommand.getCurrentMousePoint().y);&#10;    } else if (leftChart.getChartType() == ChartType.OBV) {&#10;      // g.drawString(FormatUtil.formatInteger(pointedValue),actionCommand.currentMousePoint.x,actionCommand.currentMousePoint.y);&#10;    } else if (leftChart.getChartType() == ChartType.PERCENTAGE) {&#10;      g.drawString(FormatUtil.format3DecimalPlace(pointedValue) + &quot;%&quot;, actionCommand.getCurrentMousePoint().x,&#10;        actionCommand.getCurrentMousePoint().y);&#10;    } else {&#10;      g.drawString(FormatUtil.format3DecimalPlace(pointedValue), actionCommand.getCurrentMousePoint().x + 1,&#10;        actionCommand.getCurrentMousePoint().y);&#10;    }&#10;&#10;    // draw the watch table&#10;    if (leftChart != null &amp;&amp; leftChart.isVisible()) {&#10;      plotWatchTable(leftChart);&#10;    }&#10;    if (rightChart != null &amp;&amp; rightChart.isVisible()) {&#10;      plotWatchTable(rightChart);&#10;    }&#10;    this.screenActionListener.OnWatch(this, actionCommand.getCurrentMousePoint().x);&#10;  }&#10;&#10;  /**&#10;   * Draw a line with specified width using Graphics2D with anti-aliasing for professional appearance&#10;   */&#10;  private void drawLineWithWidth(Graphics g, int x1, int y1, int x2, int y2, float width) {&#10;    if (g instanceof Graphics2D) {&#10;      Graphics2D g2 = (Graphics2D) g;&#10;&#10;      // Enable anti-aliasing for smooth lines&#10;      Object oldAntiAlias = g2.getRenderingHint(RenderingHints.KEY_ANTIALIASING);&#10;      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;&#10;      Stroke oldStroke = g2.getStroke();&#10;      g2.setStroke(new BasicStroke(width, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));&#10;      g2.drawLine(x1, y1, x2, y2);&#10;      g2.setStroke(oldStroke);&#10;&#10;      // Restore previous anti-aliasing setting&#10;      if (oldAntiAlias != null) {&#10;        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, oldAntiAlias);&#10;      }&#10;    } else {&#10;      // Fallback for non-Graphics2D&#10;      g.drawLine(x1, y1, x2, y2);&#10;    }&#10;  }&#10;&#10;  // Plot function:::&#10;  public void updateBaseScreen() {&#10;    if (this.getScreenImage() == null) {&#10;      return;&#10;    }&#10;    if (this.getAllScreenImage() == null) {&#10;      return;&#10;    }&#10;    isUpdatingBaseScreen = true;&#10;    clearScreen();&#10;&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem currentChart = (ChartItem) chartObjects.elementAt(i);&#10;      if (currentChart.isVisible() &amp;&amp; currentChart.getChartType() == ChartType.PERCENTAGE) {&#10;        currentChart.getChartData().calculatePercentage(startDisplayIndex);&#10;      }&#10;&#10;      if (currentChart.isVisible() &amp;&amp; currentChart.getChartType() == ChartType.OBV) {&#10;        currentChart.getChartData().calculateOBV(startDisplayIndex, endDisplayIndex);&#10;      }&#10;&#10;    }&#10;&#10;    FBound fb = getAxisBound(AxisType.LEFTAXIS);&#10;    getAxisBound(AxisType.RIGHTAXIS);&#10;    getAxisBound(AxisType.NONE);&#10;&#10;    // plot the grid line&#10;    plotAxis(false);&#10;    // System.out.println(&quot;end plotAxis&quot;);&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem currentChart = (ChartItem) chartObjects.elementAt(i);&#10;      if (currentChart.isVisible()) {&#10;        plotChart(currentChart);&#10;      }&#10;    }&#10;&#10;    isUpdatingBaseScreen = false;&#10;  }&#10;&#10;  /**&#10;   * plot a loading messaage box in the font of the screen...&#10;   */&#10;  private void plotLoading() {&#10;    Graphics gg = getAllScreenImage().getGraphics();&#10;    int currentIndex = (loadingBarIndex++) % 4;&#10;    gg.drawImage(loadingBarImage[currentIndex],&#10;      getSize().width / 2 - loadingBarImage[currentIndex].getWidth(null) / 2, getSize().height / 2, this);&#10;  }&#10;&#10;  private void plotPercentageChart(ChartItem currentChart) {&#10;&#10;    double Max = currentChart.getChartBound().getUpperPercentageBound();&#10;    double Min = currentChart.getChartBound().getLowerPercentageBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    StockData fpoint1 = null;&#10;    StockData fpoint2 = null;&#10;&#10;    int lastValidPoint = 0;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;&#10;      if (i &gt;= currentChart.getChartData().getData().size())&#10;        continue;&#10;      fpoint1 = currentChart.getChartData().getData().get(i);&#10;      fpoint2 = currentChart.getChartData().getData().get(i - 1);&#10;&#10;      if (fpoint2.isValid()) {&#10;        lastValidPoint = i - 1;&#10;      } else {&#10;        fpoint2 = currentChart.getChartData().getData().get(lastValidPoint);&#10;      }&#10;&#10;      if (fpoint1 != null &amp;&amp; fpoint2 != null &amp;&amp; fpoint1.isValid() &amp;&amp; fpoint2.isValid()) {&#10;        try {&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = getScreenXPositionFromPoint(lastValidPoint);&#10;          int y1 = this.getScreenYPosition(fpoint1.getPercent(), Max, Min);&#10;          int y2 = getScreenYPosition(fpoint2.getPercent(), Max, Min);&#10;          drawLineWithWidth(g, x1, y1, x2, y2, 3f);&#10;          lastValidPoint = i;&#10;        } catch (Exception ee) {&#10;          ee.printStackTrace();&#10;        }&#10;      }&#10;&#10;    }&#10;&#10;  }&#10;&#10;  private void plotVolumeChart(ChartItem currentChart) {&#10;&#10;    double Max = currentChart.getChartBound().getUpperVolumeBound();// .UpperStockBound;&#10;    double Min = currentChart.getChartBound().getLowerVolumeBound();// .LowerStockBound;&#10;    Max = Math.max(Max, 1);&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    int hWidth = 1;&#10;    if (resolution &gt;= 3 &amp;&amp; resolution &lt;= 4) {&#10;      hWidth = 1;&#10;    } else if (resolution &gt;= 5 &amp;&amp; resolution &lt;= 6) {&#10;      hWidth = 3;&#10;    } else if (resolution &gt;= 7 &amp;&amp; resolution &lt;= 8) {&#10;      hWidth = 5;&#10;    } else if (resolution &gt;= 9 &amp;&amp; resolution &lt;= 10) {&#10;      hWidth = 8;&#10;    } else if (resolution &gt;= 11) {&#10;      hWidth = resolution / 2;&#10;    }&#10;&#10;    for (int i = startDisplayIndex; i &lt;= endDisplayIndex; i++) {&#10;      StockData fpoint = currentChart.getChartData().getData().get(i);&#10;      g.fill3DRect(getScreenXPositionFromPoint(i), getScreenYPosition(fpoint.getVolume(), Max, Min), hWidth,&#10;        getScreenYPosition(0, Max, Min) - getScreenYPosition(fpoint.getVolume(), Max, Min), true);&#10;    }&#10;  }&#10;&#10;  // plot the CandleChart given the chart&#10;  private void plotCandleChart(ChartItem currentChart) {&#10;    double Max = currentChart.getChartBound().getUpperStockBound();&#10;    double Min = currentChart.getChartBound().getLowerStockBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;&#10;    // Enable anti-aliasing for smooth candle rendering&#10;    if (g instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) g;&#10;      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;    }&#10;&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    int CandleWidth = 1;&#10;    if (resolution &gt;= 3 &amp;&amp; resolution &lt;= 4) {&#10;      CandleWidth = 1;&#10;    } else if (resolution &gt;= 5 &amp;&amp; resolution &lt;= 6) {&#10;      CandleWidth = 2;&#10;    } else if (resolution &gt;= 7 &amp;&amp; resolution &lt;= 8) {&#10;      CandleWidth = 3;&#10;    } else if (resolution &gt;= 9 &amp;&amp; resolution &lt;= 10) {&#10;      CandleWidth = 4;&#10;    } else if (resolution &gt;= 11) {&#10;      CandleWidth = resolution / 2 - 2;&#10;    }&#10;&#10;    for (int i = startDisplayIndex; i &lt;= endDisplayIndex; i++) {&#10;      StockData fpoint = currentChart.getChartData().getData().get(i);&#10;      if (!fpoint.isIntraDayMarked()) {&#10;        if (fpoint.isValid()) {&#10;          if (fpoint.getOpen() &gt; fpoint.getClose()) {&#10;            g.setColor(FConfig.CandleColorDown);&#10;            g.drawLine(this.getScreenXPositionFromPoint(i),&#10;              this.getScreenYPosition(fpoint.getMaximum(), Max, Min), getScreenXPositionFromPoint(i),&#10;              getScreenYPosition(fpoint.getOpen(), Max, Min));&#10;            g.fillRoundRect(this.getScreenXPositionFromPoint(i) - CandleWidth,&#10;              this.getScreenYPosition(fpoint.getOpen(), Max, Min), CandleWidth * 2 + 1,&#10;              getScreenYPosition(fpoint.getClose(), Max, Min)&#10;                - getScreenYPosition(fpoint.getOpen(), Max, Min),&#10;              1, 1);&#10;            g.setColor(FConfig.CandleColorDown2);&#10;            g.drawRoundRect(this.getScreenXPositionFromPoint(i) - CandleWidth,&#10;              this.getScreenYPosition(fpoint.getOpen(), Max, Min), CandleWidth * 2 + 1,&#10;              getScreenYPosition(fpoint.getClose(), Max, Min)&#10;                - getScreenYPosition(fpoint.getOpen(), Max, Min),&#10;              1, 1);&#10;            g.setColor(FConfig.CandleColorDown);&#10;            g.drawLine(this.getScreenXPositionFromPoint(i),&#10;              this.getScreenYPosition(fpoint.getClose(), Max, Min), getScreenXPositionFromPoint(i),&#10;              getScreenYPosition(fpoint.getMinimum(), Max, Min));&#10;            if (fpoint.getClose() == fpoint.getOpen()) {&#10;              g.drawLine(this.getScreenXPositionFromPoint(i) - CandleWidth,&#10;                this.getScreenYPosition(fpoint.getOpen(), Max, Min),&#10;                this.getScreenXPositionFromPoint(i) + CandleWidth,&#10;                getScreenYPosition(fpoint.getClose(), Max, Min));&#10;            }&#10;          } else {&#10;            g.setColor(FConfig.CandleColorUp);&#10;            g.drawLine(this.getScreenXPositionFromPoint(i),&#10;              this.getScreenYPosition(fpoint.getMaximum(), Max, Min), getScreenXPositionFromPoint(i),&#10;              getScreenYPosition(fpoint.getClose(), Max, Min));&#10;            g.fillRoundRect(this.getScreenXPositionFromPoint(i) - CandleWidth,&#10;              this.getScreenYPosition(fpoint.getClose(), Max, Min), CandleWidth * 2,&#10;              getScreenYPosition(fpoint.getOpen(), Max, Min)&#10;                - getScreenYPosition(fpoint.getClose(), Max, Min),&#10;              1, 1);&#10;            g.setColor(FConfig.CandleColorUp2);&#10;            g.drawRoundRect(this.getScreenXPositionFromPoint(i) - CandleWidth,&#10;              this.getScreenYPosition(fpoint.getClose(), Max, Min), CandleWidth * 2,&#10;              getScreenYPosition(fpoint.getOpen(), Max, Min)&#10;                - getScreenYPosition(fpoint.getClose(), Max, Min),&#10;              1, 1);&#10;            g.setColor(FConfig.CandleColorUp);&#10;            g.drawLine(this.getScreenXPositionFromPoint(i),&#10;              this.getScreenYPosition(fpoint.getOpen(), Max, Min), getScreenXPositionFromPoint(i),&#10;              getScreenYPosition(fpoint.getMinimum(), Max, Min));&#10;            if (fpoint.getClose() == fpoint.getOpen()) {&#10;              g.drawLine(this.getScreenXPositionFromPoint(i) - CandleWidth,&#10;                this.getScreenYPosition(fpoint.getOpen(), Max, Min),&#10;                this.getScreenXPositionFromPoint(i) + CandleWidth,&#10;                getScreenYPosition(fpoint.getClose(), Max, Min));&#10;            }&#10;          }&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  private void plotBarChart(ChartItem currentChart) {&#10;&#10;    double Max = currentChart.getChartBound().getUpperStockBound();&#10;    double Min = currentChart.getChartBound().getLowerStockBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(FConfig.BarColor);&#10;&#10;    int BarWidth = 1;&#10;    if (resolution &gt;= 3 &amp;&amp; resolution &lt;= 4) {&#10;      BarWidth = 1;&#10;    } else if (resolution &gt;= 5 &amp;&amp; resolution &lt;= 6) {&#10;      BarWidth = 2;&#10;    } else if (resolution &gt;= 7 &amp;&amp; resolution &lt;= 8) {&#10;      BarWidth = 3;&#10;    } else if (resolution &gt;= 9 &amp;&amp; resolution &lt;= 10) {&#10;      BarWidth = 4;&#10;    } else if (resolution &gt;= 11) {&#10;      BarWidth = (int) (resolution / 2d);&#10;    }&#10;    for (int i = startDisplayIndex; i &lt;= endDisplayIndex; i++) {&#10;      StockData fpoint = currentChart.getChartData().getData().get(i);&#10;      if (!fpoint.isIntraDayMarked()) {&#10;        if (fpoint.isValid()) {&#10;          g.drawLine(this.getScreenXPositionFromPoint(i),&#10;            this.getScreenYPosition(fpoint.getMaximum(), Max, Min), getScreenXPositionFromPoint(i),&#10;            getScreenYPosition(fpoint.getMinimum(), Max, Min));&#10;          g.drawLine(this.getScreenXPositionFromPoint(i) - BarWidth,&#10;            this.getScreenYPosition(fpoint.getOpen(), Max, Min), getScreenXPositionFromPoint(i),&#10;            getScreenYPosition(fpoint.getOpen(), Max, Min));&#10;          g.drawLine(this.getScreenXPositionFromPoint(i),&#10;            this.getScreenYPosition(fpoint.getClose(), Max, Min),&#10;            getScreenXPositionFromPoint(i) + BarWidth, getScreenYPosition(fpoint.getClose(), Max, Min));&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  private void plotBollingerBand(ChartItem currentChart) {&#10;&#10;    // System.out.println(&quot;Line : &quot; + startDisplayIndex + &quot; : &quot; +&#10;    // endDisplayIndex);&#10;    double Max = currentChart.getChartBound().getUpperStockBound();&#10;    double Min = currentChart.getChartBound().getLowerStockBound();&#10;&#10;    int N = currentChart.getChartData().getfTAconfig().bbN;&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    AnalyticalResult fTApoint1 = null;&#10;    AnalyticalResult fTApoint2 = null;&#10;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      // System.out.println(&quot;pp: &quot; + i);&#10;      fTApoint1 = currentChart.getChartData().getAnalyticalResults().get(i);&#10;      fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(i - 1);&#10;&#10;      if (fTApoint1 != null &amp;&amp; fTApoint2 != null &amp;&amp; fTApoint1.isValid() &amp;&amp; fTApoint2.isValid()) {&#10;        try {&#10;          // System.out.println(&quot;pp: &quot; + i +&quot; ---------------------&quot;);&#10;          int y1, y2;&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = this.getScreenXPositionFromPoint(i - 1);&#10;&#10;          // plot UB line&#10;          g.setColor(FConfig.BollingerBandColor);&#10;          y1 = this.getScreenYPosition(fTApoint1.getUB(), Max, Min);&#10;          y2 = getScreenYPosition(fTApoint2.getUB(), Max, Min);&#10;          // System.out.println(x1 + &quot; : &quot; + y1 + &quot; : &quot; + x2 + &quot; : &quot; +&#10;          // y2 + &quot; plot&quot;);&#10;          if (i &gt; N) {&#10;            g.drawLine(x1, y1, x2, y2);&#10;          }&#10;&#10;          // plot LB line&#10;          g.setColor(FConfig.BollingerBandColor);&#10;          y1 = this.getScreenYPosition(fTApoint1.getLB(), Max, Min);&#10;          y2 = getScreenYPosition(fTApoint2.getLB(), Max, Min);&#10;          if (i &gt; N) {&#10;            g.drawLine(x1, y1, x2, y2);&#10;          }&#10;&#10;        } catch (Exception ee) {&#10;          ee.printStackTrace();&#10;        }&#10;      }&#10;&#10;    }&#10;&#10;  }&#10;&#10;  private void plotOBV(ChartItem currentChart) {&#10;&#10;    double Max = currentChart.getChartBound().getUpperOBVBound();&#10;    double Min = currentChart.getChartBound().getLowerOBVBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    AnalyticalResult fTApoint1 = null;&#10;    AnalyticalResult fTApoint2 = null;&#10;&#10;    g.setColor(FConfig.OBVColor);&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      fTApoint1 = currentChart.getChartData().getAnalyticalResults().get(i);&#10;      fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(i - 1);&#10;&#10;      if (fTApoint1 != null &amp;&amp; fTApoint2 != null &amp;&amp; fTApoint1.isValid() &amp;&amp; fTApoint2.isValid()) {&#10;        try {&#10;&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = this.getScreenXPositionFromPoint(i - 1);&#10;&#10;          // plot OBV&#10;          int y1 = this.getScreenYPosition(fTApoint1.getOBV(), Max, Min);&#10;          int y2 = getScreenYPosition(fTApoint2.getOBV(), Max, Min);&#10;          drawLineWithWidth(g, x1, y1, x2, y2, 2f);&#10;&#10;        } catch (Exception ee) {&#10;          ee.printStackTrace();&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  private void plotMACD(ChartItem currentChart) {&#10;    // System.out.println(&quot;Line : &quot; + startDisplayIndex + &quot; : &quot; +&#10;    // endDisplayIndex);&#10;    double Max = currentChart.getChartBound().getUpperMACDBound();&#10;    double Min = currentChart.getChartBound().getLowerMACDBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    AnalyticalResult fTApoint1 = null;&#10;    AnalyticalResult fTApoint2 = null;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      fTApoint1 = currentChart.getChartData().getAnalyticalResults().get(i);&#10;      fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(i - 1);&#10;&#10;      if (fTApoint1 != null &amp;&amp; fTApoint2 != null &amp;&amp; fTApoint1.isValid() &amp;&amp; fTApoint2.isValid()) {&#10;        try {&#10;&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = this.getScreenXPositionFromPoint(i - 1);&#10;&#10;          // plot MACD1&#10;          int y1 = this.getScreenYPosition(fTApoint1.getMACD1(), Max, Min);&#10;          int y2 = getScreenYPosition(fTApoint2.getMACD1(), Max, Min);&#10;&#10;          g.setColor(FConfig.MACDColor1);&#10;          g.drawLine(x1, y1, x2, y2);&#10;&#10;          // plot MACD2&#10;          y1 = this.getScreenYPosition(fTApoint1.getMACD2(), Max, Min);&#10;          y2 = getScreenYPosition(fTApoint2.getMACD2(), Max, Min);&#10;&#10;          g.setColor(FConfig.MACDColor2);&#10;          g.drawLine(x1, y1, x2, y2);&#10;&#10;          y1 = this.getScreenYPosition(fTApoint1.getMACDdiff(), Max, Min);&#10;          y2 = this.getScreenYPosition(0, Max, Min);&#10;          g.setColor(FConfig.MACDColor3);&#10;          g.drawLine(x1, y1, x1, y2);&#10;        } catch (Exception ee) {&#10;          ee.printStackTrace();&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  private void plotWILLIAM_R(ChartItem currentChart) {&#10;&#10;    double Max = currentChart.getChartBound().getUpperWilliamRBound();&#10;    double Min = currentChart.getChartBound().getLowerWilliamRBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    AnalyticalResult fTApoint1 = null;&#10;    AnalyticalResult fTApoint2 = null;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      fTApoint1 = currentChart.getChartData().getAnalyticalResults().get(i);&#10;      fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(i - 1);&#10;&#10;      if (fTApoint1 != null &amp;&amp; fTApoint2 != null &amp;&amp; fTApoint1.isValid() &amp;&amp; fTApoint2.isValid()) {&#10;        try {&#10;&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = this.getScreenXPositionFromPoint(i - 1);&#10;&#10;          // plot %R&#10;          int y1 = this.getScreenYPosition(fTApoint1.getR(), Max, Min);&#10;          int y2 = getScreenYPosition(fTApoint2.getR(), Max, Min);&#10;          g.setColor(FConfig.WilliamRColor);&#10;          drawLineWithWidth(g, x1, y1, x2, y2, 3f);&#10;        } catch (Exception ee) {&#10;          ee.printStackTrace();&#10;        }&#10;      }&#10;    }&#10;&#10;    g.setColor(Color.red);&#10;    int x1 = this.getScreenXPositionFromPoint(startDisplayIndex);&#10;    int x2 = getScreenXPositionFromPoint(endDisplayIndex);&#10;    int y1 = this.getScreenYPosition(50, Max, Min);&#10;    // this.drawDotLine(g,x1,y1,x2,y1);&#10;    g.drawLine(x1, y1, x2, y1);&#10;&#10;  }&#10;&#10;  private void plotSTC(ChartItem currentChart) {&#10;    double Max = currentChart.getChartBound().getUpperSTCBound();&#10;    double Min = currentChart.getChartBound().getLowerSTCBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    AnalyticalResult fTApoint1 = null;&#10;    AnalyticalResult fTApoint2 = null;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      fTApoint1 = currentChart.getChartData().getAnalyticalResults().get(i);&#10;      fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(i - 1);&#10;      if (fTApoint1 != null &amp;&amp; fTApoint2 != null &amp;&amp; fTApoint1.isValid() &amp;&amp; fTApoint2.isValid()) {&#10;        try {&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = this.getScreenXPositionFromPoint(i - 1);&#10;&#10;          // plot %K&#10;          int y1 = this.getScreenYPosition(fTApoint1.getK(), Max, Min);&#10;          int y2 = getScreenYPosition(fTApoint2.getK(), Max, Min);&#10;          g.setColor(FConfig.STCColorK);&#10;          drawLineWithWidth(g, x1, y1, x2, y2, 3f);&#10;&#10;          // plot %D&#10;          y1 = this.getScreenYPosition(fTApoint1.getD(), Max, Min);&#10;          y2 = getScreenYPosition(fTApoint2.getD(), Max, Min);&#10;          g.setColor(FConfig.STCColorD);&#10;          drawLineWithWidth(g, x1, y1, x2, y2, 3f);&#10;        } catch (Exception ee) {&#10;          ee.printStackTrace();&#10;        }&#10;      }&#10;    }&#10;&#10;    g.setColor(Color.red);&#10;    int x1 = this.getScreenXPositionFromPoint(startDisplayIndex);&#10;    int x2 = getScreenXPositionFromPoint(endDisplayIndex);&#10;    int y1 = this.getScreenYPosition(80, Max, Min);&#10;    int y2 = getScreenYPosition(20, Max, Min);&#10;    g.drawLine(x1, y1, x2, y1);&#10;    g.drawLine(x1, y2, x2, y2);&#10;&#10;  }&#10;&#10;  private void plotRSI(ChartItem currentChart) {&#10;    // System.out.println(&quot;Line : &quot; + startDisplayIndex + &quot; : &quot; +&#10;    // endDisplayIndex);&#10;    double Max = currentChart.getChartBound().getUpperRSIBound();&#10;    double Min = currentChart.getChartBound().getLowerRSIBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    AnalyticalResult fTApoint1 = null;&#10;    AnalyticalResult fTApoint2 = null;&#10;    int lastValidPoint = 0;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      fTApoint1 = currentChart.getChartData().getAnalyticalResults().get(i);&#10;      fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(i - 1);&#10;      if (fTApoint2.isValid()) {&#10;        lastValidPoint = i - 1;&#10;      } else {&#10;        fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(lastValidPoint);&#10;      }&#10;      // plot the RSI line&#10;      if (fTApoint1 != null &amp;&amp; fTApoint2 != null &amp;&amp; fTApoint1.isValid() &amp;&amp; fTApoint2.isValid()) {&#10;        try {&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = this.getScreenXPositionFromPoint(lastValidPoint);&#10;          int y1 = this.getScreenYPosition(fTApoint1.getRSI(), Max, Min);&#10;          int y2 = getScreenYPosition(fTApoint2.getRSI(), Max, Min);&#10;          g.setColor(FConfig.RSIColor);&#10;          drawLineWithWidth(g, x1, y1 , x2, y2 , 3f);&#10;          lastValidPoint = i;&#10;        } catch (Exception ee) {&#10;        }&#10;      }&#10;    }&#10;    // plot the parellel line.&#10;    g.setColor(Color.red);&#10;    int x1 = this.getScreenXPositionFromPoint(startDisplayIndex);&#10;    int x2 = getScreenXPositionFromPoint(endDisplayIndex);&#10;    int y1 = this.getScreenYPosition(70, Max, Min);&#10;    int y2 = getScreenYPosition(30, Max, Min);&#10;    drawDotLine(g, x1, y1, x2, y1);&#10;    drawDotLine(g, x1, y2, x2, y2);&#10;&#10;  }&#10;&#10;  private void plotMovingAverage(ChartItem currentChart) {&#10;&#10;    double Max = currentChart.getChartBound().getUpperStockBound();&#10;    double Min = currentChart.getChartBound().getLowerStockBound();&#10;    int N1, N2, N3;&#10;&#10;    if (currentChart.getChartType() == ChartType.SIMPLE_MOVING_AVERAGE) {&#10;      N1 = currentChart.getChartData().getfTAconfig().SMAN1;&#10;      N2 = currentChart.getChartData().getfTAconfig().SMAN2;&#10;      N3 = currentChart.getChartData().getfTAconfig().SMAN3;&#10;&#10;    } else if (currentChart.getChartType() == ChartType.WEIGHTED_MOVING_AVERAGE) {&#10;      N1 = currentChart.getChartData().getfTAconfig().WMAN1;&#10;      N2 = currentChart.getChartData().getfTAconfig().WMAN2;&#10;      N3 = currentChart.getChartData().getfTAconfig().WMAN3;&#10;    } else if (currentChart.getChartType() == ChartType.EXPONENTIAL_MOVING_AVERAGE) {&#10;      N1 = 0;&#10;      N2 = 0;&#10;      N3 = 0;&#10;    } else {&#10;      N1 = 0;&#10;      N2 = 0;&#10;      N3 = 0;&#10;    }&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    AnalyticalResult fTApoint1 = null;&#10;    AnalyticalResult fTApoint2 = null;&#10;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      fTApoint1 = currentChart.getChartData().getAnalyticalResults().get(i);&#10;      fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(i - 1);&#10;&#10;      if (fTApoint1 != null &amp;&amp; fTApoint2 != null &amp;&amp; fTApoint1.isValid() &amp;&amp; fTApoint2.isValid()) {&#10;        try {&#10;          int y1, y2;&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = this.getScreenXPositionFromPoint(i - 1);&#10;&#10;          // plot MA1 line&#10;          g.setColor(FConfig.MAColor1);&#10;          y1 = this.getScreenYPosition(fTApoint1.getMA1(), Max, Min);&#10;          y2 = getScreenYPosition(fTApoint2.getMA1(), Max, Min);&#10;          if (i &gt; N1) {&#10;            drawLineWithWidth(g, x1, y1, x2, y2, 2f);&#10;          }&#10;&#10;          // plot MA2 line&#10;          g.setColor(FConfig.MAColor2);&#10;          y1 = this.getScreenYPosition(fTApoint1.getMA2(), Max, Min);&#10;          y2 = getScreenYPosition(fTApoint2.getMA2(), Max, Min);&#10;          if (i &gt; N2) {&#10;            drawLineWithWidth(g, x1, y1, x2, y2, 2f);&#10;          }&#10;&#10;          // plot MA3 line&#10;          g.setColor(FConfig.MAColor3);&#10;          y1 = this.getScreenYPosition(fTApoint1.getMA3(), Max, Min);&#10;          y2 = getScreenYPosition(fTApoint2.getMA3(), Max, Min);&#10;          if (i &gt; N3) {&#10;            drawLineWithWidth(g, x1, y1, x2, y2, 2f);&#10;          }&#10;&#10;        } catch (Exception ee) {&#10;          ee.printStackTrace();&#10;        }&#10;      }&#10;&#10;    }&#10;&#10;  }&#10;&#10;  private void plotLineChart(ChartItem currentChart) {&#10;&#10;    double Max = currentChart.getChartBound().getUpperStockBound();&#10;    double Min = currentChart.getChartBound().getLowerStockBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(FConfig.LineColor);&#10;&#10;    StockData fpoint1 = null;&#10;    StockData fpoint2 = null;&#10;    int lastValidPoint = 0;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      fpoint1 = currentChart.getChartData().getData().get(i);&#10;      fpoint2 = currentChart.getChartData().getData().get(i - 1);&#10;      if (fpoint2.isValid()) {&#10;        lastValidPoint = i - 1;&#10;      } else {&#10;        fpoint2 = currentChart.getChartData().getData().get(lastValidPoint);&#10;      }&#10;      if (fpoint1 != null &amp;&amp; fpoint2 != null &amp;&amp; fpoint1.isValid() &amp;&amp; fpoint2.isValid()) {&#10;        try {&#10;          int x1 = getScreenXPositionFromPoint(i);&#10;          int x2 = getScreenXPositionFromPoint(lastValidPoint);&#10;          int y1 = getScreenYPosition(fpoint1.getClose(), Max, Min);&#10;          int y2 = getScreenYPosition(fpoint2.getClose(), Max, Min);&#10;&#10;          int y0 = getScreenYPosition(Min, Max, Min);&#10;          drawLineWithWidth(g, x1, y1, x2, y2, 3f);&#10;&#10;          // g.setColor(Color.red);&#10;          // g.fillRect(x1, y1, Math.abs(x2-x1),y0-y1);&#10;          lastValidPoint = i;&#10;        } catch (Exception ee) {&#10;          log.warning(&quot;Error plotting line chart at index &quot; + i + &quot;: &quot; + ee.getMessage());&#10;        }&#10;      }&#10;&#10;    }&#10;&#10;  }&#10;&#10;  // only parallel or vertical line can be plotted.&#10;  private void drawDotLine(Graphics g, int x1, int y1, int x2, int y2) {&#10;&#10;    if (x1 == x2) {&#10;      /* Y axis */&#10;      int p1, p2;&#10;      p1 = Math.min(y1, y2);&#10;      p2 = Math.max(y1, y2);&#10;      for (int i = p1; i &lt;= p2 - 2; i = i + 4) {&#10;        g.drawLine(x1, i, x1, i + 1);&#10;      }&#10;    } else if (y1 == y2) {&#10;      /* X axis */&#10;      int p1, p2;&#10;      p1 = Math.min(x1, x2);&#10;      p2 = Math.max(x1, x2);&#10;      for (int i = p1; i &lt;= p2 - 2; i = i + 4) {&#10;        g.drawLine(i, y1, i + 1, y1);&#10;      }&#10;    }&#10;&#10;  }&#10;&#10;  private void plotXAxis(ChartItem currentChart, boolean isLabel) {&#10;    // Use consistent grid color&#10;    if (gridColor == null) {&#10;      gridColor = new Color(230, 230, 235); // Match Y-axis grid color&#10;    }&#10;    int dpoint = endDisplayIndex;&#10;    Graphics g = getAllScreenImage().getGraphics();&#10;    Graphics gg = getScreenImage().getGraphics();&#10;&#10;    // when the resolution is small, set the font size to some.&#10;    if (resolution &lt;= 4) {&#10;      g.setFont(new Font(&quot;SansSerif&quot;, Font.PLAIN, 11));&#10;      gg.setFont(new Font(&quot;SansSerif&quot;, Font.PLAIN, 11));&#10;    }&#10;&#10;    if (currentChart.isShowXaxis()) {&#10;      if (currentChart.getChartData().dataInterval == DataInterval.DAILY) {&#10;        for (int i = startDisplayIndex; i &lt; dpoint; i++) {&#10;          if (i &gt;= currentChart.getChartData().getData().size()) {&#10;            // log.warning(&quot;ChartData: &quot; +&#10;            // currentChart.getChartData().getData().size() + &quot;&#10;            // dpoint: &quot; + dpoint);&#10;            continue;&#10;          }&#10;          int j = Math.max(i - 1, startDisplayIndex);&#10;          StockData fpoint = currentChart.getChartData().getData().get(i);&#10;          StockData fpoint2 = currentChart.getChartData().getData().get(j);&#10;          if (fpoint.getMonth() != fpoint2.getMonth()) {&#10;            if (!isLabel) {&#10;              gg.setColor(gridColor);&#10;              // Draw solid grid lines for professional look&#10;              if (gg instanceof Graphics2D) {&#10;                Graphics2D g2d = (Graphics2D) gg;&#10;                g2d.setStroke(new BasicStroke(0.5f));&#10;                g2d.drawLine(getScreenXPositionFromPoint(i), topSpace, getScreenXPositionFromPoint(i),&#10;                  topSpace + getYAxisWidth());&#10;                g2d.setStroke(new BasicStroke(1.0f));&#10;              } else {&#10;                drawDotLine(gg, getScreenXPositionFromPoint(i), topSpace, getScreenXPositionFromPoint(i),&#10;                  topSpace + getYAxisWidth());&#10;              }&#10;              continue;&#10;            }&#10;&#10;            g.setColor(new Color(80, 80, 80)); // Professional dark gray for tick marks&#10;            g.drawLine(getScreenXPositionFromPoint(i), topSpace + getYAxisWidth(),&#10;              getScreenXPositionFromPoint(i), topSpace + getYAxisWidth() + 2);&#10;            String dateMY = FormatUtil.formatMonth(fpoint.getDate());&#10;            if (bottomSpace &gt; 8) {&#10;              g.drawString(dateMY, getScreenXPositionFromPoint(i) - 10, topSpace + getYAxisWidth() + 14);&#10;&#10;              if (fpoint.getMonth() == 1)&#10;                g.drawString(fpoint.getYear() + &quot;&quot;, getScreenXPositionFromPoint(i) - 10,&#10;                  topSpace + getYAxisWidth() + 30);&#10;&#10;              // if (fpoint.getMonth())&#10;            }&#10;          }&#10;        }&#10;      } else if (currentChart.getChartData().dataInterval == DataInterval.WEEKLY) {&#10;        for (int i = startDisplayIndex; i &lt; dpoint; i++) {&#10;          int j = Math.max(i - 1, startDisplayIndex);&#10;          StockData fpoint = currentChart.getChartData().getData().get(i);&#10;          StockData fpoint2 = currentChart.getChartData().getData().get(j);&#10;          if (fpoint.getMonth() != fpoint2.getMonth() &amp;&amp; fpoint.getMonth() % 3 == 1) {&#10;            if (!isLabel) {&#10;              gg.setColor(gridColor);&#10;              drawDotLine(gg, getScreenXPositionFromPoint(i), topSpace, getScreenXPositionFromPoint(i),&#10;                topSpace + getYAxisWidth());&#10;              continue;&#10;            }&#10;&#10;            g.setColor(Color.black);&#10;            g.drawLine(getScreenXPositionFromPoint(i), topSpace + getYAxisWidth(),&#10;              getScreenXPositionFromPoint(i), topSpace + getYAxisWidth() + 4);&#10;            String dateMY = fpoint.getMonth() + &quot;-&quot; + fpoint.getYear();&#10;            if (bottomSpace &gt; 8) {&#10;              g.drawString(dateMY, getScreenXPositionFromPoint(i), topSpace + getYAxisWidth() + 11);&#10;            }&#10;          }&#10;        }&#10;      } else if (currentChart.getChartData().dataInterval == DataInterval.MONTHLY) {&#10;        for (int i = startDisplayIndex; i &lt; dpoint; i++) {&#10;          // System.out.println(&quot;ADFA&quot;);&#10;          int j = Math.max(i - 1, startDisplayIndex);&#10;          StockData fpoint = currentChart.getChartData().getData().get(i);&#10;          StockData fpoint2 = currentChart.getChartData().getData().get(j);&#10;          if (fpoint.getYear() != fpoint2.getYear()) {&#10;            if (!isLabel) {&#10;              gg.setColor(gridColor);&#10;              drawDotLine(gg, getScreenXPositionFromPoint(i), topSpace, getScreenXPositionFromPoint(i),&#10;                topSpace + getYAxisWidth());&#10;              continue;&#10;            }&#10;&#10;            g.setColor(Color.black);&#10;            g.drawLine(getScreenXPositionFromPoint(i), topSpace + getYAxisWidth(),&#10;              getScreenXPositionFromPoint(i), topSpace + getYAxisWidth() + 4);&#10;            String dateY = String.valueOf(fpoint.getYear());&#10;            if (bottomSpace &gt; 8) {&#10;              g.drawString(dateY, getScreenXPositionFromPoint(i), topSpace + getYAxisWidth() + 11);&#10;            }&#10;          }&#10;        }&#10;      } else if (currentChart.getChartData().dataInterval == DataInterval.INTRADAY) {&#10;        for (int i = startDisplayIndex; i &lt; dpoint; i++) {&#10;          int j = Math.max(i - 1, startDisplayIndex);&#10;          StockData fpoint = currentChart.getChartData().getData().get(i);&#10;          if (fpoint.getMinute() == 0 &amp;&amp; fpoint.getHour() != 0) {&#10;            if (!isLabel) {&#10;              gg.setColor(gridColor);&#10;              drawDotLine(gg, getScreenXPositionFromPoint(i), topSpace, getScreenXPositionFromPoint(i),&#10;                topSpace + getYAxisWidth());&#10;              continue;&#10;            }&#10;&#10;            g.setColor(Color.black);&#10;            g.drawLine(getScreenXPositionFromPoint(i), topSpace + getYAxisWidth(),&#10;              getScreenXPositionFromPoint(i), topSpace + getYAxisWidth() + 4);&#10;&#10;            String dateTime = fpoint.getHour() + &quot;:00&quot;;&#10;            if (bottomSpace &gt; 8) {&#10;              g.drawString(dateTime, getScreenXPositionFromPoint(i), topSpace + getYAxisWidth() + 11);&#10;            }&#10;          }&#10;        }&#10;      }&#10;    }&#10;&#10;  }&#10;&#10;  private void drawCompareTable() {&#10;    ChartItem lcchart = getLeftChart();&#10;    if (lcchart != null &amp;&amp; lcchart.getChartType() == ChartType.PERCENTAGE) {&#10;      // get the number of Percentage chart.....&#10;      int count = 0;&#10;      for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;        ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;        if (cchart.getChartType() == ChartType.PERCENTAGE) {&#10;          count++;&#10;        }&#10;      }&#10;      // draw the table.&#10;      int x1 = getSize().width - rightSpace - 150;&#10;      int y1 = topSpace + 5;&#10;      int ww = 145;&#10;      int hh = 14 * count + 6;&#10;      if (actionCommand.getCurrentMousePoint().x &gt; x1 &amp;&amp; actionCommand.getCurrentMousePoint().x &lt; (x1 + ww)&#10;        &amp;&amp; actionCommand.getCurrentMousePoint().y &gt; y1&#10;        &amp;&amp; actionCommand.getCurrentMousePoint().y &lt; (y1 + hh)) {&#10;        return;&#10;      }&#10;      Graphics gg = getAllScreenImage().getGraphics();&#10;      gg.setColor(new Color(240, 240, 240));&#10;      // gg.fill3DRect(x1, y1, ww, hh, true);&#10;      int lcount = 1;&#10;      for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;        ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;        if (cchart.getChartType() == ChartType.PERCENTAGE) {&#10;&#10;          gg.setFont(FConfig.DEFAULT_FONT);&#10;          String Name = cchart.getChartData().getName();&#10;          String slabel = cchart.getChartData().getCode() + &quot; &quot; + Name;&#10;          int labelWith = gg.getFontMetrics().charsWidth(slabel.toCharArray(), 0, slabel.length());&#10;          // gg.setColor(new Color(128, 128, 128));&#10;          // gg.fill3DRect(getSize().width - rightSpace - labelWith +&#10;          // 5, topSpace + 5 + 3 + (lcount - 1) * 18, labelWith, 19,&#10;          // true);&#10;          gg.setColor(cchart.getFirstColor());&#10;          gg.drawString(slabel, getSize().width - rightSpace - labelWith + 5, topSpace + 5 + 3 + lcount * 17);&#10;          lcount++;&#10;        }&#10;      }&#10;&#10;    }&#10;&#10;  }&#10;&#10;  // draw the chart name .&#10;  private void drawLabel(ChartItem currentChart) {&#10;&#10;    // Skip drawing labels for overlay indicators (they share the main chart panel)&#10;    // These indicators don't get their own label since they overlay on the price chart&#10;    if (currentChart.getChartType() == ChartType.SIMPLE_MOVING_AVERAGE ||&#10;        currentChart.getChartType() == ChartType.WEIGHTED_MOVING_AVERAGE ||&#10;        currentChart.getChartType() == ChartType.EXPONENTIAL_MOVING_AVERAGE ||&#10;        currentChart.getChartType() == ChartType.BOLLINGERBAND) {&#10;      return; // Don't draw label for overlay indicators&#10;    }&#10;&#10;    Graphics g = getAllScreenImage().getGraphics();&#10;&#10;    // Use professional font with anti-aliasing&#10;    g.setFont(new Font(&quot;SansSerif&quot;, Font.BOLD, FConfig.SCREEN_FONT_SIZE));&#10;    if (g instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) g;&#10;      g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);&#10;    }&#10;&#10;    if (currentChart.getAxisBar() == AxisType.LEFTAXIS) {&#10;      if (currentChart.getChartType() == ChartType.BAR || currentChart.getChartType() == ChartType.LINE&#10;        || currentChart.getChartType() == ChartType.CANDLE) {&#10;        g.setColor(currentChart.getFirstColor());&#10;        String cname = &quot;&quot;;&#10;        cname = currentChart.getChartData().getName();&#10;        g.drawString(currentChart.getChartData().getCode() + &quot; &quot; + cname, leftSpace + 5,&#10;          FConfig.SCREEN_FONT_SIZE + 10);&#10;      }&#10;&#10;      if (currentChart.getChartType() == ChartType.PERCENTAGE) {&#10;        g.setColor(currentChart.getFirstColor());&#10;        StockData fpoint = currentChart.getChartData().getData().get(startDisplayIndex);&#10;        String sdate = &quot;&quot;;&#10;        if (currentChart.getChartData().dataInterval == DataInterval.INTRADAY) {&#10;          sdate = lbArray[22][language] + &quot; : &quot; + FormatUtil.formatTime(fpoint.getHour(), fpoint.getMinute());&#10;        } else {&#10;          sdate = lbArray[21][language] + &quot; : &quot; + fpoint.getDay() + &quot;-&quot; + fpoint.getMonth() + &quot;-&quot;&#10;            + fpoint.getYear();&#10;        }&#10;        g.drawString(sdate, leftSpace + 5, FConfig.SCREEN_FONT_SIZE + 10);&#10;      }&#10;&#10;    }&#10;&#10;    // Use slightly smaller, regular weight font for indicator labels&#10;    g.setFont(new Font(&quot;SansSerif&quot;, Font.PLAIN, FConfig.SCREEN_FONT_SIZE - 2));&#10;&#10;    if (currentChart.getChartType() == ChartType.VOLUME) {&#10;      g.setColor(new Color(60, 60, 60)); // Professional dark gray&#10;      g.drawString(lbArray[9][language], leftSpace + 5, FConfig.SCREEN_FONT_SIZE + 10);&#10;    } else if (currentChart.getChartType() == ChartType.MACD) {&#10;      String tempString;&#10;      tempString = lbArray[20][language];&#10;      tempString = tempString + &quot; (&quot; + currentChart.getChartData().getfTAconfig().MACDLEMA + &quot;-&quot;&#10;        + currentChart.getChartData().getfTAconfig().MACDSEMA + &quot;)&quot;;&#10;      g.setColor(FConfig.MACDColor1);&#10;      g.drawString(tempString, leftSpace + 5, FConfig.SCREEN_FONT_SIZE + 10);&#10;      tempString = &quot;EMA(&quot; + currentChart.getChartData().getfTAconfig().MACDAEMA + &quot;)&quot;;&#10;      g.setColor(FConfig.MACDColor2);&#10;      g.drawString(tempString, leftSpace + 5 + 110, FConfig.SCREEN_FONT_SIZE + 10);&#10;      tempString = &quot;DIFF&quot;;&#10;      g.setColor(FConfig.MACDColor3);&#10;      g.drawString(tempString, leftSpace + 100, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;    } else if (currentChart.getChartType() == ChartType.EXPONENTIAL_MOVING_AVERAGE) {&#10;      String tempString;&#10;      g.setColor(FConfig.MAColor1);&#10;      tempString = &quot;EMA(&quot; + currentChart.getChartData().getfTAconfig().EMA1 + &quot;)&quot;;&#10;      g.drawString(tempString, leftSpace + 5, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;      tempString = &quot;EMA(&quot; + currentChart.getChartData().getfTAconfig().EMA2 + &quot;)&quot;;&#10;      g.setColor(FConfig.MAColor2);&#10;      g.drawString(tempString, leftSpace + 5 + 110, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;      tempString = &quot;EMA(&quot; + currentChart.getChartData().getfTAconfig().EMA3 + &quot;)&quot;;&#10;      g.setColor(FConfig.MAColor3);&#10;      g.drawString(tempString, leftSpace + 5 + 220, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;    } else if (currentChart.getChartType() == ChartType.SIMPLE_MOVING_AVERAGE) {&#10;      String tempString;&#10;      g.setColor(FConfig.MAColor1);&#10;      tempString = &quot;SMA(&quot; + currentChart.getChartData().getfTAconfig().SMAN1 + &quot;)&quot;;&#10;      g.drawString(tempString, leftSpace + 5, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;      tempString = &quot;SMA(&quot; + currentChart.getChartData().getfTAconfig().SMAN2 + &quot;)&quot;;&#10;      g.setColor(FConfig.MAColor2);&#10;      g.drawString(tempString, leftSpace + 5 + 110, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;      tempString = &quot;SMA(&quot; + currentChart.getChartData().getfTAconfig().SMAN3 + &quot;)&quot;;&#10;      g.setColor(FConfig.MAColor3);&#10;      g.drawString(tempString, leftSpace + 5 + 220, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;    } else if (currentChart.getChartType() == ChartType.WEIGHTED_MOVING_AVERAGE) {&#10;      String tempString;&#10;      g.setColor(FConfig.MAColor1);&#10;      tempString = &quot;WMA(&quot; + currentChart.getChartData().getfTAconfig().WMAN1 + &quot;)&quot;;&#10;      g.drawString(tempString, leftSpace + 5, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;      tempString = &quot;WMA(&quot; + currentChart.getChartData().getfTAconfig().WMAN2 + &quot;)&quot;;&#10;      g.setColor(FConfig.MAColor2);&#10;      g.drawString(tempString, leftSpace + 5 + 110, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;      tempString = &quot;WMA(&quot; + currentChart.getChartData().getfTAconfig().WMAN3 + &quot;)&quot;;&#10;      g.setColor(FConfig.MAColor3);&#10;      g.drawString(tempString, leftSpace + 5 + 220, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;    } else if (currentChart.getChartType() == ChartType.BOLLINGERBAND) {&#10;      String tempString;&#10;      g.setColor(FConfig.BollingerBandColor);&#10;      tempString = &quot;SMA(&quot; + currentChart.getChartData().getfTAconfig().bbN + &quot;)&quot;;&#10;      tempString = tempString + &quot;  &quot; + lbArray[22][language] + &quot;(&quot;&#10;        + currentChart.getChartData().getfTAconfig().bbDevation + &quot;)&quot;;&#10;      g.drawString(tempString, leftSpace + 5, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;    } else if (currentChart.getChartType() == ChartType.RSI) {&#10;      String tempString;&#10;      tempString = lbArray[17][language] + &quot; (&quot; + currentChart.getChartData().getfTAconfig().RSIPeriod + &quot;)&quot;;&#10;      g.setColor(new Color(60, 60, 60)); // Professional dark gray&#10;      g.drawString(tempString, leftSpace + 5, FConfig.SCREEN_FONT_SIZE + 10);&#10;&#10;    } else if (currentChart.getChartType() == ChartType.OBV) {&#10;      g.setColor(new Color(60, 60, 60)); // Professional dark gray&#10;      g.drawString(currentChart.getChartData().getCode() + &quot; &quot; + lbArray[19][language],&#10;        leftSpace + 10, FConfig.SCREEN_FONT_SIZE + 10);&#10;    } else if (currentChart.getChartType() == ChartType.STC) {&#10;      // Draw chart name in dark gray&#10;      String chartName = lbArray[18][language];&#10;      g.setColor(new Color(60, 60, 60)); // Professional dark gray&#10;      g.drawString(chartName, leftSpace + 10, FConfig.SCREEN_FONT_SIZE + 10);&#10;&#10;      // Calculate position for %K label based on chart name width&#10;      int chartNameWidth = g.getFontMetrics().stringWidth(chartName);&#10;      int xPosK = leftSpace + 10 + chartNameWidth + 20; // 20px spacing&#10;&#10;      // Draw %K label&#10;      String tempStringK = &quot;%K(&quot; + currentChart.getChartData().getfTAconfig().STCKPeriod + &quot;)&quot;;&#10;      g.setColor(FConfig.STCColorK);&#10;      g.drawString(tempStringK, xPosK, FConfig.SCREEN_FONT_SIZE + 10);&#10;&#10;      // Calculate position for %D label based on %K label width&#10;      int kLabelWidth = g.getFontMetrics().stringWidth(tempStringK);&#10;      int xPosD = xPosK + kLabelWidth + 20; // 20px spacing&#10;&#10;      // Draw %D label&#10;      String tempStringD = &quot;%D(&quot; + currentChart.getChartData().getfTAconfig().STCDPeriod + &quot;)&quot;;&#10;      g.setColor(FConfig.STCColorD);&#10;      g.drawString(tempStringD, xPosD, FConfig.SCREEN_FONT_SIZE + 10);&#10;    } else if (currentChart.getChartType() == ChartType.WILLIAM_R) {&#10;      String tempString = currentChart.getChartData().getCode() + &quot; &quot; + lbArray[21][language];&#10;      tempString = tempString + &quot;(&quot; + currentChart.getChartData().getfTAconfig().WilliamPeriod + &quot;)&quot;;&#10;      g.setColor(new Color(60, 60, 60)); // Professional dark gray&#10;      g.drawString(tempString, leftSpace + 10, FConfig.SCREEN_FONT_SIZE + 10);&#10;    }&#10;  }&#10;&#10;  // plot the Left YAxis&#10;  private synchronized void plotYAxis(ChartItem currentChart, boolean isLabel) {&#10;    if (currentChart == null) {&#10;      return;&#10;    }&#10;    if (currentChart.getChartBound() == null) {&#10;      return;&#10;    }&#10;&#10;    // Use a more subtle grid color for professional appearance&#10;    if (gridColor == null) {&#10;      gridColor = new Color(230, 230, 235); // Softer grid lines&#10;    }&#10;&#10;    // calculate the actual bound in the Yaxis.&#10;    double Max = currentChart.getUpperBound();&#10;    double Min = currentChart.getLowerBound();&#10;&#10;    float div = (float) (Max - Min) / 5f;&#10;    float ddiv = div;&#10;&#10;    if (div &lt; 1 &amp;&amp; div &gt;= 0.1) {&#10;      int tempd = Math.round((div * 10));&#10;      ddiv = (tempd) / 10f;&#10;    } else if (div &lt; 0.1 &amp;&amp; div &gt;= 0.01) {&#10;      int tempd = Math.round(div * 100);&#10;      ddiv = (tempd) / 100f;&#10;    } else if (div &lt; 10 &amp;&amp; div &gt;= 1) {&#10;      int tempd = (int) (div);&#10;      ddiv = tempd;&#10;    } else if (div &lt; 100 &amp;&amp; div &gt;= 10) {&#10;      int tempd = (int) (div);&#10;      ddiv = tempd;&#10;    } else if (div &lt; 1000 &amp;&amp; div &gt;= 100) {&#10;      int tempd = (int) (div / 10);&#10;      tempd = tempd * 10;&#10;      ddiv = tempd;&#10;    } else if (div &gt;= 1000) {&#10;      int tempd = (int) (div / 1000);&#10;      tempd = tempd * 1000;&#10;      ddiv = tempd;&#10;    }&#10;&#10;    int tempi = (int) ((float) Min / ddiv);&#10;    float fmin = (tempi * ddiv);&#10;    double sg;&#10;    sg = (tempi) * ddiv; // the first grid line value;&#10;&#10;    // if ((Max/ddiv)&gt;100) return;&#10;    // it is used to fix the bug that ddiv == 0, it occur where the server&#10;    // data error.&#10;    if ((ddiv &lt; 0.0001f) || ((sg + 20 * ddiv) &lt; Max)) {&#10;      return;&#10;    }&#10;&#10;    // if it is TA chart then 0 to 100 axis&#10;    if (currentChart.getChartType() == ChartType.RSI || currentChart.getChartType() == ChartType.STC&#10;      || currentChart.getChartType() == ChartType.WILLIAM_R) {&#10;      sg = 0.0f;&#10;      ddiv = 20f;&#10;    }&#10;&#10;    Graphics g = getAllScreenImage().getGraphics();&#10;    Graphics gg = getScreenImage().getGraphics();&#10;&#10;    // if the screen is small, reduce the font size&#10;    if (this.getSize().height &lt; 150) {&#10;      g.setFont(new Font(&quot;&quot;, 0, 10));&#10;      gg.setFont(new Font(&quot;&quot;, 0, 10));&#10;    } else {&#10;      g.setFont(FConfig.DEFAULT_FONT);&#10;      gg.setFont(FConfig.DEFAULT_FONT);&#10;&#10;    }&#10;&#10;    if (currentChart.getAxisBar() == AxisType.LEFTAXIS) {&#10;      for (; sg &lt;= Max; sg = sg + ddiv) {&#10;        int ypos = getScreenYPosition(sg, Max, Min);&#10;        if (sg &lt; Min || sg &gt; Max) {&#10;          continue;&#10;        }&#10;        if (!isLabel) {&#10;          // Draw solid grid lines with subtle color for professional look&#10;          gg.setColor(gridColor);&#10;          if (gg instanceof Graphics2D) {&#10;            Graphics2D g2d = (Graphics2D) gg;&#10;            g2d.setStroke(new BasicStroke(0.5f)); // Thin, subtle grid lines&#10;            g2d.drawLine(leftSpace, ypos, leftSpace + getXAxisWidth(), ypos);&#10;            g2d.setStroke(new BasicStroke(1.0f)); // Reset stroke&#10;          } else {&#10;            drawDotLine(gg, leftSpace, ypos, leftSpace + getXAxisWidth(), ypos);&#10;          }&#10;          continue;&#10;        }&#10;&#10;        // Draw axis tick marks&#10;        g.setColor(new Color(80, 80, 80)); // Professional dark gray&#10;        g.drawLine(leftSpace, ypos, leftSpace - 3, ypos);&#10;        g.setColor(currentChart.getFirstColor());&#10;        String ss;&#10;        if (currentChart.getChartType() == ChartType.VOLUME) {&#10;          ss = FormatUtil.formatInteger(sg);&#10;        } else if (currentChart.getChartType() == ChartType.PERCENTAGE) {&#10;          ss = FormatUtil.formatInteger(sg) + &quot;%&quot;;&#10;        } else if (currentChart.getChartType() == ChartType.RSI || currentChart.getChartType() == ChartType.STC&#10;          || currentChart.getChartType() == ChartType.WILLIAM_R) {&#10;          ss = String.valueOf((int) (sg + 0.5));&#10;        } else if (currentChart.getChartType() == ChartType.OBV) {&#10;          ss = FormatUtil.formatOBV(sg);&#10;        } else {&#10;          if (sg &gt; 1000) {&#10;            // ss = String.valueOf((int)(sg+0.5));&#10;            ss = FormatUtil.formatInteger(sg + 0.5);&#10;          } else {&#10;            ss = FormatUtil.format2DecimalPlace(sg);&#10;          }&#10;        }&#10;        // Use professional dark gray for axis labels&#10;        g.setColor(new Color(60, 60, 60));&#10;        int strLength = g.getFontMetrics().charsWidth(ss.toCharArray(), 0, ss.length());&#10;&#10;        g.drawString(ss, leftSpace - strLength - 10, ypos + 3);&#10;      }&#10;    } else if (currentChart.getAxisBar() == AxisType.RIGHTAXIS) {&#10;      for (; sg &lt; Max; sg = sg + ddiv) {&#10;        if (sg &lt; Min || sg &gt; Max) {&#10;          continue;&#10;        }&#10;        int ypos = getScreenYPosition(sg, Max, Min);&#10;        g.setColor(new Color(60, 60, 60)); // Professional dark gray&#10;        g.drawLine(leftSpace + getXAxisWidth(), ypos, leftSpace + getXAxisWidth() + 3, ypos);&#10;        String ss = FormatUtil.format2DecimalPlace(sg);&#10;        g.setColor(currentChart.getFirstColor());&#10;        g.drawString(ss, leftSpace + getXAxisWidth() + 6, ypos + 3);&#10;      }&#10;    }&#10;  }&#10;&#10;  // switch to different type of chart to plot&#10;  private void plotChart(ChartItem currentChart) {&#10;    switch (currentChart.getChartType()) {&#10;      case LINE:&#10;        plotLineChart(currentChart);&#10;        break;&#10;      case BAR:&#10;        plotBarChart(currentChart);&#10;        break;&#10;&#10;      case CANDLE:&#10;        plotCandleChart(currentChart);&#10;        break;&#10;&#10;      case VOLUME:&#10;        plotVolumeChart(currentChart);&#10;        break;&#10;&#10;      case PERCENTAGE:&#10;        plotPercentageChart(currentChart);&#10;        break;&#10;&#10;      case SIMPLE_MOVING_AVERAGE:&#10;        plotMovingAverage(currentChart);&#10;        break;&#10;&#10;      case WEIGHTED_MOVING_AVERAGE:&#10;        plotMovingAverage(currentChart);&#10;        break;&#10;&#10;      case EXPONENTIAL_MOVING_AVERAGE:&#10;        plotMovingAverage(currentChart);&#10;        break;&#10;&#10;      case BOLLINGERBAND:&#10;        plotBollingerBand(currentChart);&#10;        break;&#10;&#10;      case RSI:&#10;        plotRSI(currentChart);&#10;        break;&#10;&#10;      case MACD:&#10;        plotMACD(currentChart);&#10;        break;&#10;&#10;      case WILLIAM_R:&#10;        plotWILLIAM_R(currentChart);&#10;        break;&#10;&#10;      case OBV:&#10;        plotOBV(currentChart);&#10;        break;&#10;&#10;      case STC:&#10;        plotSTC(currentChart);&#10;        break;&#10;&#10;    }&#10;&#10;  }&#10;&#10;  // clear the Screen&#10;  private synchronized boolean clearScreen() {&#10;    Graphics screenG = getScreenImage().getGraphics();&#10;&#10;    // Enable anti-aliasing for smooth rendering&#10;    if (screenG instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) screenG;&#10;      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;      g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);&#10;    }&#10;&#10;    // Use a subtle gradient background for professional look&#10;    if (screenG instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) screenG;&#10;      GradientPaint gradient = new GradientPaint(&#10;        0, 0, new Color(255, 255, 255),&#10;        0, getSize().height, new Color(248, 248, 250)&#10;      );&#10;      g2d.setPaint(gradient);&#10;      g2d.fillRect(0, 0, getSize().width, getSize().height);&#10;    } else {&#10;      screenG.setColor(FConfig.ChatBackground);&#10;      screenG.fillRect(0, 0, getSize().width, getSize().height);&#10;    }&#10;    return true;&#10;  }&#10;&#10;  // remove all charts.&#10;  public void removeAllCharts() {&#10;    this.chartObjects.removeAllElements();&#10;    updateBaseScreen();&#10;  }&#10;&#10;  // plot the Axis&#10;  private boolean plotAxis(boolean isLabel) {&#10;    Graphics screenG = getAllScreenImage().getGraphics();&#10;&#10;    // Enable anti-aliasing for smooth lines&#10;    if (screenG instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) screenG;&#10;      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;      g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);&#10;    }&#10;&#10;    // Draw main axes with a professional dark gray color&#10;    screenG.setColor(new Color(80, 80, 80));&#10;    if (screenG instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) screenG;&#10;      g2d.setStroke(new BasicStroke(1.5f));&#10;    }&#10;&#10;    screenG.drawLine(leftSpace, topSpace, leftSpace, topSpace + getYAxisWidth());&#10;    screenG.drawLine(leftSpace, topSpace + getYAxisWidth(), leftSpace + getXAxisWidth(),&#10;      topSpace + getYAxisWidth());&#10;&#10;    // Reset to normal stroke&#10;    if (screenG instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) screenG;&#10;      g2d.setStroke(new BasicStroke(1.0f));&#10;    }&#10;&#10;    screenG.setColor(FConfig.ScreenBackground);&#10;&#10;    try {&#10;      for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;        ChartItem currentChart = (ChartItem) chartObjects.elementAt(i);&#10;        if (currentChart.isVisible()) {&#10;          plotXAxis(currentChart, isLabel);&#10;          plotYAxis(currentChart, isLabel);&#10;          drawLabel(currentChart);&#10;        }&#10;      }&#10;    } catch (Exception e) {&#10;      log.warning(&quot;Error plotting chart axes: &quot; + e.getMessage());&#10;    }&#10;    return true;&#10;  }&#10;&#10;  // get the Maximum Number of point that the screen can display.&#10;  private int getMaxNumberOfDisplayPoint() {&#10;    // because minimum pixels per point.&#10;    return (getXAxisWidth() - 2) / minResolution - 2;&#10;  }&#10;&#10;  // get the Maximum Number of display point that the screen can display in&#10;  // the current resoluation&#10;  private int getMaxNumberOfDisplayPointInCurrentResolution() {&#10;    return (getXAxisWidth() - 2) / resolution;&#10;  }&#10;&#10;  // retrieve the (central) point position in the screen&#10;  public int getScreenXPositionFromPoint(int pointIndex) {&#10;    return leftSpace + 1 + (pointIndex - startDisplayIndex) * resolution + resolution / 2;&#10;  }&#10;&#10;  // retrieve index from screenPos (Xaxis)&#10;  public int getPointIndexFromScreen(int screenPos) {&#10;    return startDisplayIndex + (screenPos - leftSpace - 1) / resolution;&#10;  }&#10;&#10;  // retrieve the Abract Y position given the value and the range.....&#10;  public int getScreenYPosition(double value, double MaxValue, double MinValue) {&#10;    MinValue = MinValue - 0.0001f;&#10;    double dpos = (double) getYAxisWidth() - ((value - MinValue) / (MaxValue - MinValue) * getYAxisWidth())&#10;      + topSpace;&#10;    int pos = (int) Math.round(dpos);&#10;    return pos;&#10;  }&#10;&#10;  public double getYValueFromScreen(int y, double MaxValue, double MinValue) {&#10;    double dValue = ((double) (getYAxisWidth() - y + topSpace) / getYAxisWidth()) * (MaxValue - MinValue)&#10;      + MinValue;&#10;    return dValue;&#10;  }&#10;&#10;  public void setSpace(int ileftSpace, int irightSpace, int itopSpace, int ibottomSpace) {&#10;    leftSpace = ileftSpace;&#10;    rightSpace = irightSpace;&#10;    topSpace = itopSpace;&#10;    bottomSpace = ibottomSpace;&#10;  }&#10;&#10;  public void mouseDragged(MouseEvent e) {&#10;    if (actionCommand.getActionType() == ActionType.WATCH&#10;      || actionCommand.getActionType() == ActionType.MOVE_CHART) {&#10;      if (!isWithinChartRegion(e.getX(), e.getY())) {&#10;        actionCommand.setProcessing(false);&#10;        repaint();&#10;        return;&#10;      }&#10;    }&#10;    switch (actionCommand.getActionType()) {&#10;      case ZOOM_IN:&#10;      case INSERT_LINE:&#10;      case GOLDEN_PARTITION:&#10;        actionCommand.getCurrentMousePoint().x = e.getPoint().x;&#10;        actionCommand.getCurrentMousePoint().y = e.getPoint().y;&#10;        repaint();&#10;        break;&#10;&#10;      case MOVE_CHART:&#10;        if (e.getPoint().x &gt; actionCommand.getCurrentMousePoint().x + 1) {&#10;          this.moveLeft();&#10;          actionCommand.getCurrentMousePoint().x = e.getPoint().x;&#10;          actionCommand.getCurrentMousePoint().y = e.getPoint().y;&#10;        } else if (e.getPoint().x &lt; actionCommand.getCurrentMousePoint().x - 1) {&#10;          this.moveRight();&#10;          actionCommand.getCurrentMousePoint().x = e.getPoint().x;&#10;          actionCommand.getCurrentMousePoint().y = e.getPoint().y;&#10;        }&#10;        break;&#10;    }&#10;&#10;  }&#10;&#10;  public void mouseMoved(MouseEvent e) {&#10;    if (!isWithinChartRegion(e.getX(), e.getY())) {&#10;      actionCommand.setProcessing(false);&#10;&#10;    }&#10;&#10;    actionCommand.getCurrentMousePoint().x = e.getX();&#10;    actionCommand.getCurrentMousePoint().y = e.getY();&#10;    switch (actionCommand.getActionType()) {&#10;      case INSERT_PARALLEL_LINE:&#10;        if (actionCommand.getLineRecords().size() == 0) {&#10;          actionCommand.setProcessing(false);&#10;        } else {&#10;          actionCommand.setProcessing(true);&#10;          repaint();&#10;        }&#10;        break;&#10;&#10;      case WATCH:&#10;        actionCommand.setProcessing(true);&#10;        repaint();&#10;        break;&#10;&#10;      case NONE_ACTION:&#10;      default:&#10;        actionCommand.setProcessing(false);&#10;        break;&#10;    }&#10;&#10;  }&#10;&#10;  public void mousePressed(MouseEvent e) {&#10;&#10;    if (!isWithinChartRegion(e.getX(), e.getY())) {&#10;      actionCommand.setProcessing(false);&#10;      return;&#10;    }&#10;&#10;    switch (actionCommand.getActionType()) {&#10;      case ZOOM_IN:&#10;      case INSERT_LINE:&#10;      case GOLDEN_PARTITION:&#10;        actionCommand.setProcessing(true);&#10;        actionCommand.getStartMousePoint().x = e.getPoint().x;&#10;        actionCommand.getStartMousePoint().y = e.getPoint().y;&#10;        break;&#10;&#10;      case MOVE_CHART:&#10;        Toolkit toolkit = Toolkit.getDefaultToolkit();&#10;        Cursor c = toolkit.createCustomCursor(moveCursorImage, new Point(16, 16), &quot;img&quot;);&#10;        setCursor(c);&#10;&#10;        actionCommand.setProcessing(true);&#10;        actionCommand.getStartMousePoint().x = e.getPoint().x;&#10;        actionCommand.getStartMousePoint().y = e.getPoint().y;&#10;        actionCommand.getCurrentMousePoint().x = e.getPoint().x;&#10;        actionCommand.getCurrentMousePoint().y = e.getPoint().y;&#10;        break;&#10;&#10;    }&#10;&#10;  }&#10;&#10;  public void mouseReleased(MouseEvent e) {&#10;    if (actionCommand.getActionType() == ActionType.WATCH&#10;      || actionCommand.getActionType() == ActionType.MOVE_CHART) {&#10;      if (!isWithinChartRegion(e.getX(), e.getY())) {&#10;        actionCommand.setProcessing(false);&#10;        return;&#10;      }&#10;    }&#10;&#10;    setCursor(null);&#10;&#10;    FLine fline;&#10;    switch (actionCommand.getActionType()) {&#10;&#10;      ///// Handle Zoom in action&#10;      ///// ///////////////////////////////////////////////////////////////////&#10;      case ZOOM_IN:&#10;        // actionCommand.mouseFlag = false;&#10;        actionCommand.setProcessing(false);&#10;        actionCommand.getReleaseMousePoint().x = e.getPoint().x;&#10;        actionCommand.getReleaseMousePoint().y = e.getPoint().y;&#10;        int index1 = getPointIndexFromScreen(actionCommand.getReleaseMousePoint().x);&#10;        int index2 = getPointIndexFromScreen(actionCommand.getStartMousePoint().x);&#10;&#10;        if (Math.abs(index1 - index2) &gt; 5) {&#10;          int startIndex = Math.min(index1, index2);&#10;          int endIndex = Math.max(index1, index2);&#10;          if (endIndex &gt; endDisplayIndex) {&#10;            endIndex = endDisplayIndex;&#10;          }&#10;          if (startIndex &lt; startDisplayIndex) {&#10;            startIndex = startDisplayIndex;&#10;          }&#10;          // record the previous position;&#10;          actionCommand.getZoomRecords().addElement(new Point(startDisplayIndex, endDisplayIndex));&#10;          // change the zoom&#10;          zoom(startIndex, endIndex);&#10;        } else {&#10;          repaint();&#10;        }&#10;        break;&#10;&#10;      ///// Handle insert line action&#10;      ///// //////////////////////////////////////////////////////////////////&#10;      case INSERT_LINE:&#10;        actionCommand.setProcessing(false);&#10;        actionCommand.getReleaseMousePoint().x = e.getPoint().x;&#10;        actionCommand.getReleaseMousePoint().y = e.getPoint().y;&#10;        if (FLine.isFixedLine()) {&#10;          fline = new FLine(actionCommand.getStartMousePoint().x, actionCommand.getStartMousePoint().y,&#10;            actionCommand.getReleaseMousePoint().x, actionCommand.getReleaseMousePoint().y);&#10;          actionCommand.getLineRecords().addElement(fline);&#10;        } else {&#10;          int x1 = getPointIndexFromScreen(actionCommand.getStartMousePoint().x);&#10;          int x2 = getPointIndexFromScreen(actionCommand.getReleaseMousePoint().x);&#10;          float y1, y2;&#10;          ChartItem cchart = this.getLeftChart();&#10;          if (cchart != null) {&#10;            float Min = (float) cchart.getLowerBound();&#10;            float Max = (float) cchart.getUpperBound();&#10;            y1 = (float) getYValueFromScreen(actionCommand.getStartMousePoint().y, Max, Min);&#10;            y2 = (float) getYValueFromScreen(actionCommand.getReleaseMousePoint().y, Max, Min);&#10;            fline = new FLine(x1, y1, x2, y2);&#10;            fline.getPoint1().x = actionCommand.getStartMousePoint().x;&#10;            fline.getPoint1().y = actionCommand.getStartMousePoint().y;&#10;            fline.getPoint2().x = actionCommand.getReleaseMousePoint().x;&#10;            fline.getPoint2().y = actionCommand.getReleaseMousePoint().y;&#10;            actionCommand.getLineRecords().addElement(fline);&#10;          }&#10;        }&#10;        repaint();&#10;        break;&#10;&#10;      case GOLDEN_PARTITION:&#10;        actionCommand.setProcessing(false);&#10;        actionCommand.getReleaseMousePoint().x = e.getPoint().x;&#10;        actionCommand.getReleaseMousePoint().y = e.getPoint().y;&#10;&#10;        if (FLine.isFixedLine()) {&#10;          fline = new FLine(actionCommand.getStartMousePoint().x, actionCommand.getStartMousePoint().y,&#10;            actionCommand.getReleaseMousePoint().x, actionCommand.getReleaseMousePoint().y);&#10;          actionCommand.setGoldenPartitionLine(fline);&#10;        } else {&#10;          int x1 = getPointIndexFromScreen(actionCommand.getStartMousePoint().x);&#10;          int x2 = getPointIndexFromScreen(actionCommand.getReleaseMousePoint().x);&#10;          float y1, y2;&#10;          ChartItem cchart = this.getLeftChart();&#10;          if (cchart != null) {&#10;            float Min = (float) cchart.getLowerBound();&#10;            float Max = (float) cchart.getUpperBound();&#10;            y1 = (float) getYValueFromScreen(actionCommand.getStartMousePoint().y, Max, Min);&#10;            y2 = (float) getYValueFromScreen(actionCommand.getReleaseMousePoint().y, Max, Min);&#10;            fline = new FLine(x1, y1, x2, y2);&#10;            fline.getPoint1().x = actionCommand.getStartMousePoint().x;&#10;            fline.getPoint1().y = actionCommand.getStartMousePoint().y;&#10;            fline.getPoint2().x = actionCommand.getReleaseMousePoint().x;&#10;            fline.getPoint2().y = actionCommand.getReleaseMousePoint().y;&#10;            actionCommand.setGoldenPartitionLine(fline);&#10;          }&#10;        }&#10;&#10;        if (Math.abs(actionCommand.getStartMousePoint().y - actionCommand.getReleaseMousePoint().y) &lt; 5) {&#10;          actionCommand.setGoldenPartitionLine(null);&#10;        }&#10;&#10;        repaint();&#10;        break;&#10;&#10;      // handle move chart action -- disable it when release the button&#10;      // .//////////////////////////////&#10;      case MOVE_CHART:&#10;        actionCommand.setProcessing(false);&#10;        break;&#10;&#10;    }&#10;  }&#10;&#10;  public void mouseEntered(MouseEvent e) {&#10;    repaint();&#10;  }&#10;&#10;  public void mouseExited(MouseEvent e) {&#10;    switch (actionCommand.getActionType()) {&#10;      // still perform the action.&#10;      case GOLDEN_PARTITION:&#10;      case INSERT_PARALLEL_LINE:&#10;      case INSERT_LINE:&#10;      case ZOOM_IN:&#10;        break;&#10;&#10;      // cancel the action.&#10;      default:&#10;        actionCommand.setProcessing(false);&#10;        repaint();&#10;        this.screenActionListener.OnWatch(this, -999);&#10;        break;&#10;    }&#10;  }&#10;&#10;  protected boolean isWithinCloseButton(int x, int y) {&#10;&#10;    return x &gt;= (getWidth() - 17) &amp;&amp; x &lt;= getWidth() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 15;&#10;&#10;  }&#10;&#10;  public void mouseClicked(MouseEvent e) {&#10;&#10;    if (isWithinCloseButton(e.getX(), e.getY())) {&#10;      this.setVisible(false);&#10;      return;&#10;    }&#10;&#10;    if (!isWithinChartRegion(e.getX(), e.getY())) {&#10;      actionCommand.setProcessing(false);&#10;      return;&#10;    }&#10;    switch (actionCommand.getActionType()) {&#10;      case ZOOM_IN:&#10;        String mparamString = e.paramString();&#10;        // if right click mouse&#10;        if (mparamString.indexOf(&quot;mods=4&quot;) &gt; 0) {&#10;          this.undoZoom();&#10;        }&#10;        break;&#10;&#10;      // when mouse click insert a parallel line into&#10;      // action.lineRecords.///////////////////////////////////&#10;      case INSERT_PARALLEL_LINE:&#10;        if (!isWithinChartRegion(e.getX(), e.getY())) {&#10;          return;&#10;        }&#10;&#10;        FLine fline = (FLine) actionCommand.getLineRecords().lastElement();&#10;        Point rpoint = new Point(0, 0);&#10;        if (fline.getPoint1().x &lt; fline.getPoint2().x) {&#10;          rpoint.x = fline.getPoint1().x;&#10;          rpoint.y = fline.getPoint1().y;&#10;        } else {&#10;          rpoint.x = fline.getPoint2().x;&#10;          rpoint.y = fline.getPoint2().y;&#10;        }&#10;        int dx = +actionCommand.getCurrentMousePoint().x - rpoint.x;&#10;        int dy = +actionCommand.getCurrentMousePoint().y - rpoint.y;&#10;        if (FLine.isFixedLine()) {&#10;          FLine newFline = new FLine(fline.getPoint1().x + dx, fline.getPoint1().y + dy, fline.getPoint2().x + dx,&#10;            fline.getPoint2().y + dy);&#10;          actionCommand.getLineRecords().addElement(newFline);&#10;        } else {&#10;&#10;          int x1 = getPointIndexFromScreen(fline.getPoint1().x + dx);&#10;          int x2 = getPointIndexFromScreen(fline.getPoint2().x + dx);&#10;          float y1, y2;&#10;          ChartItem cchart = this.getLeftChart();&#10;          if (cchart != null) {&#10;            float Min = (float) cchart.getLowerBound();&#10;            float Max = (float) cchart.getUpperBound();&#10;            y1 = (float) getYValueFromScreen(fline.getPoint1().y + dy, Max, Min);&#10;            y2 = (float) getYValueFromScreen(fline.getPoint2().y + dy, Max, Min);&#10;            FLine newfline = new FLine(x1, y1, x2, y2);&#10;            newfline.getPoint1().x = fline.getPoint1().x + dx;&#10;            newfline.getPoint1().y = fline.getPoint1().y + dy;&#10;            newfline.getPoint2().x = fline.getPoint2().x + dx;&#10;            newfline.getPoint2().y = fline.getPoint2().y + dy;&#10;            actionCommand.getLineRecords().addElement(newfline);&#10;          }&#10;&#10;        }&#10;        repaint();&#10;        break;&#10;      case EDIT_TEXT:&#10;        ChartItem cchart = this.getLeftChart();&#10;        if (cchart != null) {&#10;          float Min = (float) cchart.getLowerBound();&#10;          float Max = (float) cchart.getUpperBound();&#10;          int x1 = getPointIndexFromScreen(e.getX());&#10;          float y1 = (float) getYValueFromScreen(e.getY(), Max, Min);&#10;          JDialog jd = new JDialog();&#10;          String s = JOptionPane.showInputDialog(this, &quot;&quot;, &quot;&quot;);&#10;          if (s != null &amp;&amp; !s.trim().equals(&quot;&quot;)) {&#10;            FText textRecord = new FText(s, x1, y1);&#10;            actionCommand.getTextRecords().addElement(textRecord);&#10;          }&#10;        }&#10;        repaint();&#10;        break;&#10;    }&#10;  }&#10;&#10;  // End: response of mouse action&#10;  // .............................................&#10;  // move chart to left&#10;  public void moveLeft() {&#10;    if ((startDisplayIndex - 1) &gt;= 0) {&#10;      int startIndex = startDisplayIndex - 1;&#10;      int endIndex = endDisplayIndex - 1;&#10;      zoom(startIndex, endIndex);&#10;      this.updateBaseScreen();&#10;      this.repaint();&#10;    }&#10;  }&#10;&#10;  // move chart to right&#10;  public void moveRight() {&#10;    if ((endDisplayIndex + 1) &lt; maxNumberOfChartPoint) {&#10;      int startIndex = startDisplayIndex + 1;&#10;      int endIndex = endDisplayIndex + 1;&#10;      zoom(startIndex, endIndex);&#10;      this.updateBaseScreen();&#10;      this.repaint();&#10;    }&#10;  }&#10;&#10;  public ChartItem getLeftChart() {&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;      if (cchart.getAxisBar() == AxisType.LEFTAXIS) {&#10;        return cchart;&#10;      }&#10;    }&#10;    return null;&#10;  }&#10;&#10;  public synchronized ChartItem getRightChart() {&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;      if (cchart.getAxisBar() == AxisType.RIGHTAXIS) {&#10;        return cchart;&#10;      }&#10;    }&#10;    return null;&#10;  }&#10;&#10;  public void undoInsertLine() {&#10;    if (actionCommand.getLineRecords().size() &gt; 0) {&#10;      FLine fline = (FLine) actionCommand.getLineRecords().lastElement();&#10;      actionCommand.getLineRecords().removeElement(fline);&#10;    }&#10;    repaint();&#10;&#10;  }&#10;&#10;  // Undo Zoom&#10;  public Point undoZoom() {&#10;    int endIndex = maxNumberOfChartPoint - 1;&#10;    int startIndex = Math.max(0, endIndex - getMaxNumberOfDisplayPoint());&#10;    Point ozoom = new Point(startIndex, endIndex);&#10;    if (actionCommand.getZoomRecords().size() &gt; 0) {&#10;      ozoom = (Point) actionCommand.getZoomRecords().lastElement();&#10;      actionCommand.getZoomRecords().removeElement(ozoom);&#10;      zoom(ozoom.x, ozoom.y);&#10;      return ozoom;&#10;    } else if (actionCommand.getZoomRecords().size() == 0) {&#10;      zoom(ozoom.x, ozoom.y);&#10;      return ozoom;&#10;    }&#10;    return ozoom;&#10;  }&#10;&#10;  public synchronized void addScreenActionListen(ScreenActionListener ss) {&#10;    screenActionListener = ss;&#10;  }&#10;&#10;  public synchronized void flipLoading() {&#10;    repaint();&#10;  }&#10;&#10;  public synchronized Image getScreenImage() {&#10;    return screenImage;&#10;  }&#10;&#10;  public void setScreenImage(Image screenImage) {&#10;    this.screenImage = screenImage;&#10;  }&#10;&#10;  public Image getAllScreenImage() {&#10;    return allscreenImage;&#10;  }&#10;&#10;  public void setAllScreenImage(Image allscreenImage) {&#10;    this.allscreenImage = allscreenImage;&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ic.core;&#10;&#10;import com.ic.data.*;&#10;import com.ic.util.FormatUtil;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.Point;&#10;import java.awt.event.MouseEvent;&#10;import java.awt.event.MouseListener;&#10;import java.awt.event.MouseMotionListener;&#10;import java.io.Serial;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Vector;&#10;import java.util.logging.Logger;&#10;&#10;public class ChartScreen extends JPanel implements MouseListener, MouseMotionListener {&#10;&#10;  public static final int NONE = 0;&#10;  public static final int LOADING = 1;&#10;  public static final int STARTED = 2;&#10;  private static final Logger log = Logger.getLogger(ChartScreen.class.getName());&#10;  @Serial&#10;  private static final long serialVersionUID = -6984851432299222149L;&#10;  // Removed legacy lbArray; now use ChartLabelText.getLabel(index, language)&#10;  // Define of Resolution and display information&#10;  private final int minResolution = 3;&#10;  private final int language = FConfig.constEnglish;&#10;  // A list of add ChartUIObject needed to plot to this screen.....&#10;  private final Vector chartObjects = new Vector();&#10;  public Image[] loadingBarImage = new Image[4];&#10;  // The screenImage for drawing....&#10;  private Image screenImage = null; // the chart image&#10;  private Image allscreenImage = null; // the full screen image&#10;  private Image moveCursorImage = null;&#10;  // Action Object to record and repersent all the action.&#10;  private ActionCommand actionCommand = new ActionCommand();&#10;  private int screenState = STARTED;&#10;  private boolean isUpdatingBaseScreen = false; // check isUpdatingBaseScreen&#10;  // or not.&#10;  private Color gridColor;&#10;  /// The space of top, left, right and bottom in pixels.&#10;  private int topSpace = 20;&#10;  private int leftSpace = 40;&#10;  private int rightSpace = 20;&#10;  private int bottomSpace = 30;&#10;  // The maximun number of point that the chart have....&#10;  private int maxNumberOfChartPoint = 0;&#10;  private int loadingBarIndex = 0;&#10;  private int resolution = 3; // must be &lt; 4 pixels per point.&#10;  private int startDisplayIndex = 0;&#10;  private int endDisplayIndex = 0;&#10;  private ScreenActionListener screenActionListener = null;&#10;  private boolean IsWatching = false;&#10;  private int watchingPoint = 0;&#10;&#10;  public ChartScreen(int TOPSpace, int BOTTOMSpace, int LEFTSpace, int RIGHTSpace) {&#10;    topSpace = TOPSpace;&#10;    bottomSpace = BOTTOMSpace;&#10;    leftSpace = LEFTSpace;&#10;    rightSpace = RIGHTSpace;&#10;&#10;    moveCursorImage = new ImageIcon(getClass().getResource(&quot;/hand.png&quot;)).getImage();&#10;    try {&#10;      addMouseListener(this);&#10;      addMouseMotionListener(this);&#10;      init();&#10;    } catch (Exception e) {&#10;      log.warning(e.getMessage());&#10;    }&#10;&#10;  }&#10;&#10;  private ChartScreen() {&#10;    try {&#10;      addMouseListener(this);&#10;      addMouseMotionListener(this);&#10;      init();&#10;    } catch (Exception e) {&#10;      log.warning(e.getMessage());&#10;    }&#10;  }&#10;&#10;  public int getScreenState() {&#10;    return screenState;&#10;  }&#10;&#10;  public void setScreenState(int ss) {&#10;    screenState = ss;&#10;    this.repaint();&#10;  }&#10;&#10;  public ActionCommand getActionCommand() {&#10;    return actionCommand;&#10;  }&#10;&#10;  public void setActionCommand(ActionCommand actionCommand) {&#10;    this.actionCommand = actionCommand;&#10;  }&#10;&#10;  // get the chart given the key.&#10;  public ChartItem getChart(String key) {&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem pchart = (ChartItem) chartObjects.elementAt(i);&#10;      if (pchart.getKey().equals(key)) {&#10;        return pchart;&#10;      }&#10;    }&#10;    return null;&#10;  }&#10;&#10;  public ActionCommand getAction() {&#10;    return actionCommand;&#10;  }&#10;&#10;  // add a chart to this screen&#10;  public void addChart(ChartItem newChart) {&#10;    int tempNumb = 0;&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;      if (cchart.getKey().equals(newChart.getKey())) {&#10;        chartObjects.removeElement(cchart);&#10;      }&#10;    }&#10;    chartObjects.addElement(newChart);&#10;    // get the max Number Of Chart Point......&#10;&#10;    for (int i = 0; i &lt; this.chartObjects.size(); i++) {&#10;      ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;      if (tempNumb == 0 || cchart.getChartData().getData().size() &lt; tempNumb) {&#10;        tempNumb = cchart.getChartData().getData().size();&#10;      }&#10;    }&#10;    maxNumberOfChartPoint = tempNumb;&#10;  }&#10;&#10;  // get the LowerBound and UpperBound of the L or R chart&#10;  private FBound getAxisBound(AxisType axisBarType) {&#10;&#10;    double bStockMax = -1000000f;&#10;    double bStockMin = 1000000f;&#10;&#10;    float bPercentageMax = 0;&#10;    float bPercentageMin = 100;&#10;&#10;    float bMACDMax = -1000000f;&#10;    float bMACDMin = 1000000f;&#10;&#10;    float bOBVMax = -10000f;&#10;    float bOBVMin = 100000f;&#10;&#10;    double bVolumeMax = 0;&#10;    double bVolumeMin = 0;&#10;&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;      if (cchart.getAxisBar() == axisBarType) {&#10;        if (cchart.getChartType() == ChartType.BAR || cchart.getChartType() == ChartType.CANDLE&#10;          || cchart.getChartType() == ChartType.LINE) {&#10;          double Max = cchart.getChartData().getMaximum(startDisplayIndex, endDisplayIndex, &quot;STOCK&quot;);&#10;          if (Max &gt; bStockMax) {&#10;            bStockMax = Max;&#10;          }&#10;          double Min = cchart.getChartData().getMinimum(startDisplayIndex, endDisplayIndex, &quot;STOCK&quot;);&#10;          if (Min &lt; bStockMin) {&#10;            bStockMin = Min;&#10;          }&#10;        }&#10;&#10;        if (cchart.getChartType() == ChartType.VOLUME) {&#10;          double Max = cchart.getChartData().getMaximumVolume(startDisplayIndex, endDisplayIndex);&#10;          if (Max &gt; bVolumeMax) {&#10;            bVolumeMax = Max;&#10;          }&#10;        }&#10;      }&#10;&#10;      if (cchart.getChartType() == ChartType.PERCENTAGE) {&#10;        float Max = (float) cchart.getChartData().getMaximum(startDisplayIndex, endDisplayIndex, &quot;PERCENTAGE&quot;);&#10;        if (Max &gt; bPercentageMax) {&#10;          bPercentageMax = Max;&#10;        }&#10;        float Min = (float) cchart.getChartData().getMinimum(startDisplayIndex, endDisplayIndex, &quot;PERCENTAGE&quot;);&#10;        if (Min &lt; bPercentageMin) {&#10;          bPercentageMin = Min;&#10;        }&#10;      }&#10;&#10;      if (cchart.getChartType() == ChartType.SIMPLE_MOVING_AVERAGE&#10;        || cchart.getChartType() == ChartType.WEIGHTED_MOVING_AVERAGE&#10;        || cchart.getChartType() == ChartType.EXPONENTIAL_MOVING_AVERAGE) {&#10;        double Max = cchart.getChartData().getMaximum(startDisplayIndex, endDisplayIndex, &quot;STOCK&quot;);&#10;        if (Max &gt; bStockMax) {&#10;          bStockMax = Max;&#10;        }&#10;        double Min = cchart.getChartData().getMinimum(startDisplayIndex, endDisplayIndex, &quot;STOCK&quot;);&#10;        if (Min &lt; bStockMin) {&#10;          bStockMin = Min;&#10;        }&#10;      }&#10;&#10;      if (cchart.getChartType() == ChartType.BOLLINGERBAND) {&#10;        double Max = cchart.getChartData().getMaximum(startDisplayIndex, endDisplayIndex, &quot;STOCK&quot;);&#10;        if (Max &gt; bStockMax) {&#10;          bStockMax = Max;&#10;        }&#10;        double Min = cchart.getChartData().getMinimum(startDisplayIndex, endDisplayIndex, &quot;STOCK&quot;);&#10;        if (Min &lt; bStockMin) {&#10;          bStockMin = Min;&#10;        }&#10;      }&#10;&#10;      if (cchart.getChartType() == ChartType.MACD) {&#10;        double Max = cchart.getChartData().getMaximum(startDisplayIndex, endDisplayIndex, &quot;MACD&quot;);&#10;        if (Max &gt; bStockMax) {&#10;          bMACDMax = (float) Max;&#10;        }&#10;        double Min = cchart.getChartData().getMinimum(startDisplayIndex, endDisplayIndex, &quot;MACD&quot;);&#10;        if (Min &lt; bStockMin) {&#10;          bMACDMin = (float) Min;&#10;        }&#10;      }&#10;&#10;      if (cchart.getChartType() == ChartType.OBV) {&#10;        double Max = cchart.getChartData().getMaximum(startDisplayIndex, endDisplayIndex, &quot;OBV&quot;);&#10;        if (Max &gt; bStockMax) {&#10;          bOBVMax = (float) Max;&#10;        }&#10;        double Min = cchart.getChartData().getMinimum(startDisplayIndex, endDisplayIndex, &quot;OBV&quot;);&#10;        if (Min &lt; bStockMin) {&#10;          bOBVMin = (float) Min;&#10;        }&#10;      }&#10;    }&#10;&#10;    FBound newBound = new FBound();&#10;&#10;    double ss = (bStockMax - bStockMin) * 0.1f;&#10;    newBound.setLowerStockBound(bStockMin - ss);&#10;    newBound.setUpperStockBound(bStockMax + ss);&#10;    newBound.setLowerVolumeBound(0);&#10;    newBound.setUpperVolumeBound(bVolumeMax + 5);&#10;    ss = (bPercentageMax - bPercentageMin) * 0.1f;&#10;    newBound.setLowerPercentageBound(bPercentageMin - (float) ss);&#10;    newBound.setUpperPercentageBound(bPercentageMax + (float) ss);&#10;    ss = (bMACDMax - bMACDMin) * 0.1f;&#10;    newBound.setLowerMACDBound(bMACDMin - (float) ss);&#10;    newBound.setUpperMACDBound(bMACDMax + (float) ss);&#10;    newBound.setLowerOBVBound((int) bOBVMin);&#10;    newBound.setUpperOBVBound((int) bOBVMax);&#10;&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;      if (cchart.getAxisBar() == axisBarType) {&#10;        cchart.setChartBound(newBound);&#10;      }&#10;      if (cchart.getChartType() == ChartType.PERCENTAGE &amp;&amp; axisBarType == AxisType.LEFTAXIS) {&#10;        cchart.setChartBound(newBound);&#10;      }&#10;    }&#10;    return newBound;&#10;  }&#10;&#10;  // function to initScreen, it should be called once in applet.start function&#10;  // in order to fix UI bug.&#10;  public void initScreen() {&#10;    if (getSize().width &gt; 0 &amp;&amp; getSize().height &gt; 0) {&#10;      if (getScreenImage() == null) {&#10;        setScreenImage(createImage(getSize().width, getSize().height));&#10;      }&#10;      if (getAllScreenImage() == null) {&#10;        setAllScreenImage(createImage(getSize().width, getSize().height));&#10;      }&#10;&#10;      if (loadingBarImage[0] == null) {&#10;        loadingBarImage[0] = new ImageIcon(getClass().getResource(&quot;/LoadingBar0.png&quot;)).getImage();&#10;        loadingBarImage[1] = new ImageIcon(getClass().getResource(&quot;/LoadingBar1.png&quot;)).getImage();&#10;        loadingBarImage[2] = new ImageIcon(getClass().getResource(&quot;/LoadingBar2.png&quot;)).getImage();&#10;        loadingBarImage[3] = new ImageIcon(getClass().getResource(&quot;/LoadingBar3.png&quot;)).getImage();&#10;      }&#10;    }&#10;  }&#10;&#10;  public int getStartDisplayIndex() {&#10;    return startDisplayIndex;&#10;  }&#10;&#10;  public int getEndDisplayIndex() {&#10;    return endDisplayIndex;&#10;  }&#10;&#10;  // remove a chart from this screen given the name&#10;  public boolean removeChart(String key) {&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem chartobj = (ChartItem) chartObjects.elementAt(i);&#10;      if (chartobj.getKey().equals(key)) {&#10;        chartObjects.removeElementAt(i);&#10;        return true;&#10;      }&#10;    }&#10;    return false;&#10;  }&#10;&#10;  // remove a chart from this screen given the name&#10;  public boolean removeChart(int code) {&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem chartobj = (ChartItem) chartObjects.elementAt(i);&#10;      if (chartobj.getChartData().getCode().equals(code)) {&#10;        chartObjects.removeElementAt(i);&#10;      }&#10;    }&#10;&#10;    return true;&#10;  }&#10;&#10;  public void removeChartsByType(ChartType cType) {&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem chartobj = (ChartItem) chartObjects.elementAt(i);&#10;      if (chartobj.getChartType() == cType) {&#10;        chartObjects.removeElementAt(i);&#10;        i = -1;&#10;      }&#10;    }&#10;  }&#10;&#10;  boolean isWithinChartRegion(int x, int y) {&#10;    if (x &gt;= leftSpace &amp;&amp; x &lt;= (getXAxisWidth() + leftSpace + 2)) {&#10;      return y &gt;= topSpace &amp;&amp; y &lt;= (getYAxisWidth() + topSpace);&#10;    }&#10;    return false;&#10;  }&#10;&#10;  int getXAxisWidth() {&#10;    return getSize().width - leftSpace - rightSpace;&#10;  }&#10;&#10;  int getYAxisWidth() {&#10;    return getSize().height - topSpace - bottomSpace;&#10;  }&#10;&#10;  private void init() throws Exception {&#10;    this.setBackground(FConfig.ScreenBackground);&#10;    this.setLayout(null);&#10;  }&#10;&#10;  @Override&#10;  public void setBounds(int x, int y, int w, int h) {&#10;&#10;    if (h == 0) {&#10;      return;&#10;    }&#10;    Image newImage1 = null;&#10;    Image newImage2 = null;&#10;    try {&#10;      if (getScreenImage() != null&#10;        &amp;&amp; (getScreenImage().getHeight(this) != h || getScreenImage().getWidth(this) != w)) {&#10;        newImage1 = createImage(w, h);&#10;        setScreenImage(newImage1);&#10;      }&#10;      if (getAllScreenImage() != null&#10;        &amp;&amp; (getAllScreenImage().getHeight(this) != h || getAllScreenImage().getWidth(this) != w)) {&#10;        newImage2 = createImage(w, h);&#10;        setAllScreenImage(newImage2);&#10;      }&#10;      super.setBounds(x, y, w, h);&#10;    } catch (Exception ee) {&#10;      log.warning(ee.getMessage());&#10;    }&#10;&#10;  }&#10;&#10;  public boolean zoom(int startIndex, int endIndex) {&#10;    // first, determine the new resolution.....&#10;    int numberOfpoints = endIndex - startIndex + 1;&#10;    float fpixelsperpoint = (float) (getXAxisWidth() - 2) / numberOfpoints;&#10;    resolution = (int) (fpixelsperpoint + 0.01d);&#10;&#10;    startDisplayIndex = startIndex;&#10;    endDisplayIndex = endIndex;&#10;&#10;    // update the Screen and notify to listener&#10;    this.updateBaseScreen();&#10;&#10;    // remove lines because of when using percentage..........&#10;    ChartItem ccchart = getLeftChart();&#10;    if (ccchart != null &amp;&amp; ccchart.getChartType() == ChartType.PERCENTAGE) {&#10;      actionCommand.getLineRecords().removeAllElements();&#10;      actionCommand.setGoldenPartitionLine(null);&#10;    }&#10;    this.repaint();&#10;    if (screenActionListener != null) {&#10;      screenActionListener.OnZoomCompleted(this, startDisplayIndex, endDisplayIndex);&#10;    }&#10;    return true;&#10;  }&#10;&#10;  public void watch(int watchPoint) {&#10;    // update the Screen and notify to listener&#10;    // getAction().setActionType(ActionCommand.ActionType.WATCH);&#10;    // this.updateBaseScreen();&#10;    IsWatching = true;&#10;    watchingPoint = watchPoint;&#10;    this.repaint();&#10;&#10;  }&#10;&#10;  // The function is used to plot the chart&#10;  @Override&#10;  public void update(Graphics g) {&#10;    paint(g);&#10;  }&#10;&#10;  @Override&#10;  public void paint(Graphics gg) {&#10;    if (isUpdatingBaseScreen) {&#10;      return;&#10;    }&#10;    if (getScreenImage() == null) {&#10;      setScreenImage(createImage(getSize().width, this.getSize().height));&#10;    }&#10;    if (getAllScreenImage() == null) {&#10;      setAllScreenImage(createImage(getSize().width, this.getSize().height));&#10;    }&#10;&#10;    Graphics g = getAllScreenImage().getGraphics();&#10;&#10;    // Enable anti-aliasing for professional smooth rendering&#10;    if (g instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) g;&#10;      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;      g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);&#10;      g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);&#10;      g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);&#10;    }&#10;    g.drawImage(getScreenImage(), 0, 0, getSize().width, getSize().height, this);&#10;    g.setColor(Color.black);&#10;    for (int i = 0; i &lt; actionCommand.getLineRecords().size(); i++) {&#10;      FLine fline = (FLine) actionCommand.getLineRecords().elementAt(i);&#10;      if (FLine.isFixedLine()) {&#10;        g.setColor(Color.black);&#10;        g.drawLine(fline.getPoint1().x, fline.getPoint1().y, fline.getPoint2().x, fline.getPoint2().y);&#10;      } else {&#10;        g.setColor(Color.black);&#10;        int x1 = getScreenXPositionFromPoint(fline.getIndex1());&#10;        int x2 = getScreenXPositionFromPoint(fline.getIndex2());&#10;        int y1, y2;&#10;        ChartItem cchart = getLeftChart();&#10;        if (cchart != null) {&#10;          double Max = cchart.getUpperBound();&#10;          double Min = cchart.getLowerBound();&#10;          y1 = getScreenYPosition(fline.getValue1(), Max, Min);&#10;          y2 = getScreenYPosition(fline.getValue2(), Max, Min);&#10;          g.drawLine(x1, y1, x2, y2);&#10;        }&#10;      }&#10;    }&#10;&#10;    for (int i = 0; i &lt; actionCommand.getTextRecords().size(); i++) {&#10;      FText record = (FText) actionCommand.getTextRecords().elementAt(i);&#10;&#10;      g.setColor(Color.black);&#10;      ChartItem cchart = getLeftChart();&#10;      if (cchart != null) {&#10;        double Max = cchart.getUpperBound();&#10;        double Min = cchart.getLowerBound();&#10;        int y1 = getScreenYPosition(record.getYValue(), Max, Min);&#10;        int x1 = getScreenXPositionFromPoint(record.getXIndex());&#10;        g.drawString(record.getText(), x1, y1);&#10;      }&#10;&#10;    }&#10;&#10;    // if we are not process GOLDENPAERTITION and we have one need to draw&#10;    if (actionCommand.getActionType() != ActionType.GOLDEN_PARTITION || !actionCommand.isProcessing()) {&#10;      if (actionCommand.getGoldenPartitionLine() != null) {&#10;        int MaxY = 0, MinY = 0;&#10;        int x1;&#10;        if (FLine.isFixedLine()) {&#10;          MaxY = Math.max(actionCommand.getGoldenPartitionLine().getPoint1().y,&#10;            actionCommand.getGoldenPartitionLine().getPoint2().y);&#10;          MinY = Math.min(actionCommand.getGoldenPartitionLine().getPoint1().y,&#10;            actionCommand.getGoldenPartitionLine().getPoint2().y);&#10;          x1 = actionCommand.getGoldenPartitionLine().getPoint1().x;&#10;&#10;&#10;        } else {&#10;          x1 = getScreenXPositionFromPoint(actionCommand.getGoldenPartitionLine().getIndex1());&#10;          int y1, y2;&#10;          ChartItem cchart = getLeftChart();&#10;          if (cchart != null) {&#10;            double Max = cchart.getUpperBound();&#10;            double Min = cchart.getLowerBound();&#10;            y1 = getScreenYPosition(actionCommand.getGoldenPartitionLine().getValue1(), Max, Min);&#10;            y2 = getScreenYPosition(actionCommand.getGoldenPartitionLine().getValue2(), Max, Min);&#10;            MaxY = Math.max(y1, y2);&#10;            MinY = Math.min(y1, y2);&#10;          }&#10;        }&#10;&#10;        int Y618 = (int) (MaxY - (MaxY - MinY) * 0.618f);&#10;        int Y50 = (int) (MaxY - (MaxY - MinY) * 0.50f);&#10;        int Y382 = (int) (MaxY - (MaxY - MinY) * 0.382);&#10;&#10;        g.drawString(&quot;0%&quot;, x1 + 2, MaxY - 1);&#10;        g.drawString(&quot;100%&quot;, x1 + 2, MinY - 1);&#10;        g.drawLine(x1, MaxY, leftSpace + getXAxisWidth(), MaxY);&#10;        g.drawLine(x1, MinY, leftSpace + getXAxisWidth(), MinY);&#10;        g.setColor(Color.red);&#10;        drawDotLine(g, x1, Y618, leftSpace + getXAxisWidth(), Y618);&#10;        drawDotLine(g, x1, Y50, leftSpace + getXAxisWidth(), Y50);&#10;        drawDotLine(g, x1, Y382, leftSpace + getXAxisWidth(), Y382);&#10;        g.setColor(Color.darkGray);&#10;        g.drawString(&quot;61.8%&quot;, x1 + 2, Y618 - 1);&#10;        g.drawString(&quot;50%&quot;, x1 + 2, Y50 - 1);&#10;        g.drawString(&quot;38.2%&quot;, x1 + 2, Y382 - 1);&#10;&#10;        ChartItem cchart = getLeftChart();&#10;        if (cchart != null) {&#10;          double UpperBound = cchart.getUpperBound();&#10;          double LowerBound = cchart.getLowerBound();&#10;          float v100 = (float) getYValueFromScreen(MinY, UpperBound, LowerBound);&#10;          float v618 = (float) getYValueFromScreen(Y618, UpperBound, LowerBound);&#10;          float v500 = (float) getYValueFromScreen(Y50, UpperBound, LowerBound);&#10;          float v382 = (float) getYValueFromScreen(Y382, UpperBound, LowerBound);&#10;          float v000 = (float) getYValueFromScreen(MaxY, UpperBound, LowerBound);&#10;          g.setColor(cchart.getFirstColor());&#10;          if (cchart.getChartType() == ChartType.PERCENTAGE) {&#10;            g.drawString(FormatUtil.format2DecimalPlace(v100) + &quot;%&quot;, x1 + 40, MinY - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v618) + &quot;%&quot;, x1 + 40, Y618 - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v500) + &quot;%&quot;, x1 + 40, Y50 - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v382) + &quot;%&quot;, x1 + 40, Y382 - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v000) + &quot;%&quot;, x1 + 40, MaxY - 1);&#10;          } else {&#10;            g.drawString(FormatUtil.format2DecimalPlace(v100), x1 + 40, MinY - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v618), x1 + 40, Y618 - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v500), x1 + 40, Y50 - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v382), x1 + 40, Y382 - 1);&#10;            g.drawString(FormatUtil.format2DecimalPlace(v000), x1 + 40, MaxY - 1);&#10;          }&#10;        }&#10;        cchart = getRightChart();&#10;        if (cchart != null) {&#10;          double UpperBound = cchart.getUpperBound();&#10;          double LowerBound = cchart.getLowerBound();&#10;          float v100 = (float) getYValueFromScreen(MinY, UpperBound, LowerBound);&#10;          float v618 = (float) getYValueFromScreen(Y618, UpperBound, LowerBound);&#10;          float v500 = (float) getYValueFromScreen(Y50, UpperBound, LowerBound);&#10;          float v382 = (float) getYValueFromScreen(Y382, UpperBound, LowerBound);&#10;          float v000 = (float) getYValueFromScreen(MaxY, UpperBound, LowerBound);&#10;          g.setColor(cchart.getFirstColor());&#10;&#10;          g.drawString(FormatUtil.format2DecimalPlace(v100), x1 + 80, MinY - 1);&#10;          g.drawString(FormatUtil.format2DecimalPlace(v618), x1 + 80, Y618 - 1);&#10;          g.drawString(FormatUtil.format2DecimalPlace(v500), x1 + 80, Y50 - 1);&#10;          g.drawString(FormatUtil.format2DecimalPlace(v382), x1 + 80, Y382 - 1);&#10;          g.drawString(FormatUtil.format2DecimalPlace(v000), x1 + 80, MaxY - 1);&#10;        }&#10;      }&#10;    }&#10;&#10;    /// process current action ..................................&#10;    if (this.screenState != LOADING) {&#10;      switch (actionCommand.getActionType()) {&#10;        //// ----------------------Response to Zoom Action&#10;        //// ------------------------------------------////////&#10;        case ZOOM_IN:&#10;          if (actionCommand.isProcessing()) {&#10;            Point opoint = new Point();&#10;            Point epoint = new Point();&#10;            opoint.x = Math.min(actionCommand.getStartMousePoint().x, actionCommand.getCurrentMousePoint().x);&#10;            opoint.y = Math.min(actionCommand.getStartMousePoint().y, actionCommand.getCurrentMousePoint().y);&#10;            epoint.x = Math.max(actionCommand.getStartMousePoint().x, actionCommand.getCurrentMousePoint().x);&#10;            epoint.y = Math.max(actionCommand.getStartMousePoint().y, actionCommand.getCurrentMousePoint().y);&#10;&#10;            if (opoint.y &lt; topSpace) {&#10;              opoint.y = topSpace + 1;&#10;            }&#10;            if (opoint.x &lt; leftSpace) {&#10;              opoint.x = leftSpace + 1;&#10;            }&#10;            if (epoint.y &gt; topSpace + getYAxisWidth()) {&#10;              epoint.y = topSpace + getYAxisWidth() - 1;&#10;            }&#10;            if (epoint.x &gt; leftSpace + getXAxisWidth()) {&#10;              epoint.x = leftSpace + getXAxisWidth() - 1;&#10;            }&#10;            g.drawRect(opoint.x, opoint.y, Math.abs(epoint.x - opoint.x), Math.abs(epoint.y - opoint.y));&#10;          }&#10;          break;&#10;&#10;        //// ----------------------Response to Watch Action&#10;        //// -----------------------------------------///////&#10;        case WATCH:&#10;          if (actionCommand.isProcessing() &amp;&amp; isWithinChartRegion(actionCommand.getCurrentMousePoint().x,&#10;            actionCommand.getCurrentMousePoint().y)) {&#10;            ChartItem cchart = getLeftChart();&#10;            if (cchart != null) {&#10;              g.setColor(FConfig.ToolBarColor);&#10;              g.drawLine(actionCommand.getCurrentMousePoint().x - 1, topSpace,&#10;                actionCommand.getCurrentMousePoint().x - 1, getHeight() - topSpace - bottomSpace);&#10;              drawWatchAction();&#10;            }&#10;          }&#10;          break;&#10;        //// ----------------------Response to INSERTLINE Action&#10;        //// ------------------------------------------////////&#10;        case INSERT_LINE:&#10;          // System.out.println(actionCommand.isProcessing);&#10;          if (actionCommand.isProcessing()) {&#10;            g.drawLine(actionCommand.getCurrentMousePoint().x, actionCommand.getCurrentMousePoint().y,&#10;              actionCommand.getStartMousePoint().x, actionCommand.getStartMousePoint().y);&#10;          }&#10;          break;&#10;        //// ----------------------Response to Insert Parallel Line Action&#10;        //// ------------------------------------------////////&#10;        case INSERT_PARALLEL_LINE:&#10;          // if (actionCommand.isProcessing == true &amp;&amp;&#10;          // isWithinChartRegion(actionCommand.currentMousePoint.x,actionCommand.currentMousePoint.y))&#10;          if (actionCommand.isProcessing()) {&#10;            FLine fline = (FLine) actionCommand.getLineRecords().lastElement();&#10;            Point rpoint = new Point(0, 0);&#10;            if (fline.getPoint1().x &lt; fline.getPoint2().x) {&#10;              rpoint.x = fline.getPoint1().x;&#10;              rpoint.y = fline.getPoint1().y;&#10;            } else {&#10;              rpoint.x = fline.getPoint2().x;&#10;              rpoint.y = fline.getPoint2().y;&#10;            }&#10;            int dx = +actionCommand.getCurrentMousePoint().x - rpoint.x;&#10;            int dy = +actionCommand.getCurrentMousePoint().y - rpoint.y;&#10;&#10;            g.drawLine(fline.getPoint1().x + dx, fline.getPoint1().y + dy, fline.getPoint2().x + dx,&#10;              fline.getPoint2().y + dy);&#10;          }&#10;          break;&#10;&#10;        //// ----------------------Response to Golden partition Action&#10;        //// ------------------------------------------////////&#10;        case GOLDEN_PARTITION:&#10;          // if (actionCommand.isProcessing == true &amp;&amp;&#10;          // isWithinChartRegion(actionCommand.currentMousePoint.x,actionCommand.currentMousePoint.y))&#10;          if (actionCommand.isProcessing()) {&#10;            int MaxY = Math.max(actionCommand.getStartMousePoint().y, actionCommand.getCurrentMousePoint().y);&#10;            int MinY = Math.min(actionCommand.getStartMousePoint().y, actionCommand.getCurrentMousePoint().y);&#10;&#10;            int Y618 = (int) (MaxY - (MaxY - MinY) * 0.618f);&#10;            int Y50 = (int) (MaxY - (MaxY - MinY) * 0.50f);&#10;            int Y382 = (int) (MaxY - (MaxY - MinY) * 0.382);&#10;            g.drawString(&quot;100%&quot;, actionCommand.getStartMousePoint().x + 2, MinY - 1);&#10;            g.drawLine(actionCommand.getStartMousePoint().x, MaxY, leftSpace + getXAxisWidth(), MaxY);&#10;            g.drawString(&quot;0%&quot;, actionCommand.getStartMousePoint().x + 2, MaxY - 1);&#10;            g.drawLine(actionCommand.getStartMousePoint().x, MinY, leftSpace + getXAxisWidth(), MinY);&#10;            g.setColor(Color.red);&#10;            drawDotLine(g, actionCommand.getStartMousePoint().x, Y618, leftSpace + getXAxisWidth(), Y618);&#10;            drawDotLine(g, actionCommand.getStartMousePoint().x, Y50, leftSpace + getXAxisWidth(), Y50);&#10;            drawDotLine(g, actionCommand.getStartMousePoint().x, Y382, leftSpace + getXAxisWidth(), Y382);&#10;            g.setColor(Color.darkGray);&#10;            g.drawString(&quot;38.2%&quot;, actionCommand.getStartMousePoint().x + 2, Y382 - 1);&#10;            g.drawString(&quot;50%&quot;, actionCommand.getStartMousePoint().x + 2, Y50 - 1);&#10;            g.drawString(&quot;61.8%&quot;, actionCommand.getStartMousePoint().x + 2, Y618 - 1);&#10;&#10;            ChartItem cchart = getLeftChart();&#10;            if (cchart != null) {&#10;              double UpperBound = cchart.getUpperBound();&#10;              double LowerBound = cchart.getLowerBound();&#10;              float v100 = (float) getYValueFromScreen(MinY, UpperBound, LowerBound);&#10;              float v618 = (float) getYValueFromScreen(Y618, UpperBound, LowerBound);&#10;              float v500 = (float) getYValueFromScreen(Y50, UpperBound, LowerBound);&#10;              float v382 = (float) getYValueFromScreen(Y382, UpperBound, LowerBound);&#10;              float v000 = (float) getYValueFromScreen(MaxY, UpperBound, LowerBound);&#10;              g.setColor(cchart.getFirstColor());&#10;              if (cchart.getChartType() == ChartType.PERCENTAGE) {&#10;                g.drawString(FormatUtil.format2DecimalPlace(v100) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 40, MinY - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v618) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 40, Y618 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v500) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 40, Y50 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v382) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 40, Y382 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v000) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 40, MaxY - 1);&#10;              } else {&#10;                g.drawString(FormatUtil.format2DecimalPlace(v100),&#10;                  actionCommand.getStartMousePoint().x + 40, MinY - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v618),&#10;                  actionCommand.getStartMousePoint().x + 40, Y618 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v500),&#10;                  actionCommand.getStartMousePoint().x + 40, Y50 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v382),&#10;                  actionCommand.getStartMousePoint().x + 40, Y382 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v000),&#10;                  actionCommand.getStartMousePoint().x + 40, MaxY - 1);&#10;              }&#10;            }&#10;&#10;            cchart = getRightChart();&#10;            if (cchart != null) {&#10;              double UpperBound = cchart.getUpperBound();&#10;              double LowerBound = cchart.getLowerBound();&#10;              float v100 = (float) getYValueFromScreen(MinY, UpperBound, LowerBound);&#10;              float v618 = (float) getYValueFromScreen(Y618, UpperBound, LowerBound);&#10;              float v500 = (float) getYValueFromScreen(Y50, UpperBound, LowerBound);&#10;              float v382 = (float) getYValueFromScreen(Y382, UpperBound, LowerBound);&#10;              float v000 = (float) getYValueFromScreen(MaxY, UpperBound, LowerBound);&#10;              g.setColor(cchart.getFirstColor());&#10;              if (cchart.getChartType() == ChartType.PERCENTAGE) {&#10;                g.drawString(FormatUtil.format2DecimalPlace(v100) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 80, MinY - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v618) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 80, Y618 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v500) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 80, Y50 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v382) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 80, Y382 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v000) + &quot;%&quot;,&#10;                  actionCommand.getStartMousePoint().x + 80, MaxY - 1);&#10;              } else {&#10;                g.drawString(FormatUtil.format2DecimalPlace(v100),&#10;                  actionCommand.getStartMousePoint().x + 80, MinY - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v618),&#10;                  actionCommand.getStartMousePoint().x + 80, Y618 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v500),&#10;                  actionCommand.getStartMousePoint().x + 80, Y50 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v382),&#10;                  actionCommand.getStartMousePoint().x + 80, Y382 - 1);&#10;                g.drawString(FormatUtil.format2DecimalPlace(v000),&#10;                  actionCommand.getStartMousePoint().x + 80, MaxY - 1);&#10;              }&#10;            }&#10;          }&#10;          break;&#10;&#10;      }&#10;    }&#10;&#10;    /// Plot V line when watching&#10;    if (IsWatching) {&#10;      if (watchingPoint &gt; 0) {&#10;        g.setColor(FConfig.ToolBarColor);&#10;        g.drawLine(watchingPoint, topSpace, watchingPoint, getHeight() - topSpace - bottomSpace);&#10;        actionCommand.setCurrentMousePoint(new com.ic.data.Point(watchingPoint, 0));&#10;        plotWatchTable(getLeftChart());&#10;      }&#10;      // IsWatching =false;&#10;    }&#10;    ////// plot the&#10;    ////// Axis/////////////////////////////////////////////////////////////////////////&#10;    plotAxis(true);&#10;    drawCompareTable();&#10;    // plotCloseButton();&#10;    // draw the buffered image to the screen&#10;    // /////////////////////////////////////////////////&#10;&#10;    if (this.screenState == LOADING) {&#10;      plotLoading();&#10;    }&#10;    gg.drawImage(getAllScreenImage(), 0, 0, getSize().width, getSize().height, this);&#10;  }&#10;&#10;  private void plotWatchTable(ChartItem cchart) {&#10;    Graphics g = getAllScreenImage().getGraphics();&#10;    if (cchart != null) {&#10;      int index = getPointIndexFromScreen(actionCommand.getCurrentMousePoint().x);&#10;      StockData fpoint = cchart.getChartData().getData().get(index);&#10;      AnalyticalResult fTApoint = null;&#10;      if (cchart.getChartData().getAnalyticalResults().size() &gt; index) {&#10;        fTApoint = cchart.getChartData().getAnalyticalResults().get(index);&#10;      }&#10;&#10;      String pDate = new SimpleDateFormat(&quot;MMM-dd&quot;).format(fpoint.getDate());&#10;      StringBuilder sb = new StringBuilder(200);&#10;      sb.append(pDate).append(&quot; &quot;);&#10;      int x = leftSpace + 5;&#10;      int y = this.getHeight() - bottomSpace - 3;&#10;      g.setColor(FConfig.ToolBarColor);&#10;      g.fill3DRect(x - 2, y - 16, getWidth() - 6 - rightSpace - leftSpace, 18, true);&#10;      g.setColor(Color.WHITE);&#10;      switch (cchart.getChartType()) {&#10;        case PERCENTAGE:&#10;          break;&#10;        case MACD:&#10;          sb.append(&quot;MACD1:&quot; + FormatUtil.format3DecimalPlace(fTApoint.getMACD1()));&#10;          sb.append(&quot;, MACD2: &quot; + FormatUtil.format3DecimalPlace(fTApoint.getMACD2()));&#10;          sb.append(&quot;, Diff: &quot; + FormatUtil.format3DecimalPlace(fTApoint.getMACDdiff()));&#10;          g.drawString(sb.toString(), x, y);&#10;          break;&#10;&#10;        case RSI:&#10;          sb.append(&quot;RSI:&quot;).append(fTApoint.getRSI());&#10;          g.drawString(sb.toString(), x, y);&#10;          break;&#10;&#10;        case STC:&#10;          sb.append(&quot;%K:&quot;).append(FormatUtil.format3DecimalPlace(fTApoint.getK()));&#10;          sb.append(&quot; %D:&quot;).append(FormatUtil.format3DecimalPlace(fTApoint.getD()));&#10;          g.drawString(sb.toString(), x, y);&#10;          break;&#10;&#10;        case OBV:&#10;          sb.append(&quot;OBV:&quot;).append(fTApoint.getOBV());&#10;          g.drawString(sb.toString(), x, y);&#10;          break;&#10;&#10;        case WILLIAM_R:&#10;          sb.append(&quot;William %R:&quot;).append(fTApoint.getR());&#10;          g.drawString(sb.toString(), x, y);&#10;          break;&#10;&#10;        case VOLUME:&#10;          sb.append(&quot;Volume:&quot;).append(fpoint.getVolume());&#10;          g.drawString(sb.toString(), x, y);&#10;          break;&#10;&#10;        case CANDLE:&#10;        case LINE:&#10;        case BAR:&#10;&#10;          sb.append(&quot;OPEN:&quot;).append(FormatUtil.format3DecimalPlace(fpoint.getOpen())).append(&quot;, &quot;);&#10;          sb.append(&quot;CLOSE:&quot;).append(FormatUtil.format3DecimalPlace(fpoint.getClose())).append(&quot;, &quot;);&#10;          sb.append(&quot;HIGH:&quot;).append(FormatUtil.format3DecimalPlace(fpoint.getMaximum())).append(&quot;, &quot;);&#10;          sb.append(&quot;LOW:&quot;).append(FormatUtil.format3DecimalPlace(fpoint.getMinimum())).append(&quot;, &quot;);&#10;          sb.append(&quot;VOL:&quot;).append(FormatUtil.formatInteger(fpoint.getVolume()));&#10;          g.drawString(sb.toString(), x, y);&#10;          break;&#10;      }&#10;&#10;    }&#10;&#10;  }&#10;&#10;  private void drawWatchAction() {&#10;&#10;    int indexPoint = getPointIndexFromScreen(actionCommand.getCurrentMousePoint().x);&#10;    if (indexPoint &lt; startDisplayIndex || indexPoint &gt; endDisplayIndex) {&#10;      return;&#10;    }&#10;&#10;    ChartItem leftChart = getLeftChart();&#10;    ChartItem rightChart = getRightChart();&#10;&#10;    // draw the value where the mouse pointed.&#10;    double pointedValue = this.getYValueFromScreen(actionCommand.getCurrentMousePoint().y,&#10;      leftChart.getUpperBound(), leftChart.getLowerBound());&#10;    Graphics g = getAllScreenImage().getGraphics();&#10;    g.setColor(FConfig.WatchLabelColor);&#10;    g.setFont(new Font(&quot;default&quot;, 1, 14));&#10;    if (leftChart.getChartType() == ChartType.VOLUME) {&#10;      g.drawString(String.valueOf((int) (pointedValue)), actionCommand.getCurrentMousePoint().x + 1,&#10;        actionCommand.getCurrentMousePoint().y);&#10;    } else if (leftChart.getChartType() == ChartType.OBV) {&#10;      // g.drawString(FormatUtil.formatInteger(pointedValue),actionCommand.currentMousePoint.x,actionCommand.currentMousePoint.y);&#10;    } else if (leftChart.getChartType() == ChartType.PERCENTAGE) {&#10;      g.drawString(FormatUtil.format3DecimalPlace(pointedValue) + &quot;%&quot;, actionCommand.getCurrentMousePoint().x,&#10;        actionCommand.getCurrentMousePoint().y);&#10;    } else {&#10;      g.drawString(FormatUtil.format3DecimalPlace(pointedValue), actionCommand.getCurrentMousePoint().x + 1,&#10;        actionCommand.getCurrentMousePoint().y);&#10;    }&#10;&#10;    // draw the watch table&#10;    if (leftChart != null &amp;&amp; leftChart.isVisible()) {&#10;      plotWatchTable(leftChart);&#10;    }&#10;    if (rightChart != null &amp;&amp; rightChart.isVisible()) {&#10;      plotWatchTable(rightChart);&#10;    }&#10;    this.screenActionListener.OnWatch(this, actionCommand.getCurrentMousePoint().x);&#10;  }&#10;&#10;  /**&#10;   * Draw a line with specified width using Graphics2D with anti-aliasing for professional appearance&#10;   */&#10;  private void drawLineWithWidth(Graphics g, int x1, int y1, int x2, int y2, float width) {&#10;    if (g instanceof Graphics2D) {&#10;      Graphics2D g2 = (Graphics2D) g;&#10;&#10;      // Enable anti-aliasing for smooth lines&#10;      Object oldAntiAlias = g2.getRenderingHint(RenderingHints.KEY_ANTIALIASING);&#10;      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;&#10;      Stroke oldStroke = g2.getStroke();&#10;      g2.setStroke(new BasicStroke(width, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));&#10;      g2.drawLine(x1, y1, x2, y2);&#10;      g2.setStroke(oldStroke);&#10;&#10;      // Restore previous anti-aliasing setting&#10;      if (oldAntiAlias != null) {&#10;        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, oldAntiAlias);&#10;      }&#10;    } else {&#10;      // Fallback for non-Graphics2D&#10;      g.drawLine(x1, y1, x2, y2);&#10;    }&#10;  }&#10;&#10;  // Plot function:::&#10;  public void updateBaseScreen() {&#10;    if (this.getScreenImage() == null) {&#10;      return;&#10;    }&#10;    if (this.getAllScreenImage() == null) {&#10;      return;&#10;    }&#10;    isUpdatingBaseScreen = true;&#10;    clearScreen();&#10;&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem currentChart = (ChartItem) chartObjects.elementAt(i);&#10;      if (currentChart.isVisible() &amp;&amp; currentChart.getChartType() == ChartType.PERCENTAGE) {&#10;        currentChart.getChartData().calculatePercentage(startDisplayIndex);&#10;      }&#10;&#10;      if (currentChart.isVisible() &amp;&amp; currentChart.getChartType() == ChartType.OBV) {&#10;        currentChart.getChartData().calculateOBV(startDisplayIndex, endDisplayIndex);&#10;      }&#10;&#10;    }&#10;&#10;    FBound fb = getAxisBound(AxisType.LEFTAXIS);&#10;    getAxisBound(AxisType.RIGHTAXIS);&#10;    getAxisBound(AxisType.NONE);&#10;&#10;    // plot the grid line&#10;    plotAxis(false);&#10;    // System.out.println(&quot;end plotAxis&quot;);&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem currentChart = (ChartItem) chartObjects.elementAt(i);&#10;      if (currentChart.isVisible()) {&#10;        plotChart(currentChart);&#10;      }&#10;    }&#10;&#10;    isUpdatingBaseScreen = false;&#10;  }&#10;&#10;  /**&#10;   * plot a loading messaage box in the font of the screen...&#10;   */&#10;  private void plotLoading() {&#10;    Graphics gg = getAllScreenImage().getGraphics();&#10;    int currentIndex = (loadingBarIndex++) % 4;&#10;    gg.drawImage(loadingBarImage[currentIndex],&#10;      getSize().width / 2 - loadingBarImage[currentIndex].getWidth(null) / 2, getSize().height / 2, this);&#10;  }&#10;&#10;  private void plotPercentageChart(ChartItem currentChart) {&#10;&#10;    double Max = currentChart.getChartBound().getUpperPercentageBound();&#10;    double Min = currentChart.getChartBound().getLowerPercentageBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    StockData fpoint1 = null;&#10;    StockData fpoint2 = null;&#10;&#10;    int lastValidPoint = 0;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;&#10;      if (i &gt;= currentChart.getChartData().getData().size())&#10;        continue;&#10;      fpoint1 = currentChart.getChartData().getData().get(i);&#10;      fpoint2 = currentChart.getChartData().getData().get(i - 1);&#10;&#10;      if (fpoint2.isValid()) {&#10;        lastValidPoint = i - 1;&#10;      } else {&#10;        fpoint2 = currentChart.getChartData().getData().get(lastValidPoint);&#10;      }&#10;&#10;      if (fpoint1 != null &amp;&amp; fpoint2 != null &amp;&amp; fpoint1.isValid() &amp;&amp; fpoint2.isValid()) {&#10;        try {&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = getScreenXPositionFromPoint(lastValidPoint);&#10;          int y1 = this.getScreenYPosition(fpoint1.getPercent(), Max, Min);&#10;          int y2 = getScreenYPosition(fpoint2.getPercent(), Max, Min);&#10;          drawLineWithWidth(g, x1, y1, x2, y2, 3f);&#10;          lastValidPoint = i;&#10;        } catch (Exception ee) {&#10;          ee.printStackTrace();&#10;        }&#10;      }&#10;&#10;    }&#10;&#10;  }&#10;&#10;  private void plotVolumeChart(ChartItem currentChart) {&#10;&#10;    double Max = currentChart.getChartBound().getUpperVolumeBound();// .UpperStockBound;&#10;    double Min = currentChart.getChartBound().getLowerVolumeBound();// .LowerStockBound;&#10;    Max = Math.max(Max, 1);&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    int hWidth = 1;&#10;    if (resolution &gt;= 3 &amp;&amp; resolution &lt;= 4) {&#10;      hWidth = 1;&#10;    } else if (resolution &gt;= 5 &amp;&amp; resolution &lt;= 6) {&#10;      hWidth = 3;&#10;    } else if (resolution &gt;= 7 &amp;&amp; resolution &lt;= 8) {&#10;      hWidth = 5;&#10;    } else if (resolution &gt;= 9 &amp;&amp; resolution &lt;= 10) {&#10;      hWidth = 8;&#10;    } else if (resolution &gt;= 11) {&#10;      hWidth = resolution / 2;&#10;    }&#10;&#10;    for (int i = startDisplayIndex; i &lt;= endDisplayIndex; i++) {&#10;      StockData fpoint = currentChart.getChartData().getData().get(i);&#10;      g.fill3DRect(getScreenXPositionFromPoint(i), getScreenYPosition(fpoint.getVolume(), Max, Min), hWidth,&#10;        getScreenYPosition(0, Max, Min) - getScreenYPosition(fpoint.getVolume(), Max, Min), true);&#10;    }&#10;  }&#10;&#10;  // plot the CandleChart given the chart&#10;  private void plotCandleChart(ChartItem currentChart) {&#10;    double Max = currentChart.getChartBound().getUpperStockBound();&#10;    double Min = currentChart.getChartBound().getLowerStockBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;&#10;    // Enable anti-aliasing for smooth candle rendering&#10;    if (g instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) g;&#10;      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;    }&#10;&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    int CandleWidth = 1;&#10;    if (resolution &gt;= 3 &amp;&amp; resolution &lt;= 4) {&#10;      CandleWidth = 1;&#10;    } else if (resolution &gt;= 5 &amp;&amp; resolution &lt;= 6) {&#10;      CandleWidth = 2;&#10;    } else if (resolution &gt;= 7 &amp;&amp; resolution &lt;= 8) {&#10;      CandleWidth = 3;&#10;    } else if (resolution &gt;= 9 &amp;&amp; resolution &lt;= 10) {&#10;      CandleWidth = 4;&#10;    } else if (resolution &gt;= 11) {&#10;      CandleWidth = resolution / 2 - 2;&#10;    }&#10;&#10;    for (int i = startDisplayIndex; i &lt;= endDisplayIndex; i++) {&#10;      StockData fpoint = currentChart.getChartData().getData().get(i);&#10;      if (!fpoint.isIntraDayMarked()) {&#10;        if (fpoint.isValid()) {&#10;          if (fpoint.getOpen() &gt; fpoint.getClose()) {&#10;            g.setColor(FConfig.CandleColorDown);&#10;            g.drawLine(this.getScreenXPositionFromPoint(i),&#10;              this.getScreenYPosition(fpoint.getMaximum(), Max, Min), getScreenXPositionFromPoint(i),&#10;              getScreenYPosition(fpoint.getOpen(), Max, Min));&#10;            g.fillRoundRect(this.getScreenXPositionFromPoint(i) - CandleWidth,&#10;              this.getScreenYPosition(fpoint.getOpen(), Max, Min), CandleWidth * 2 + 1,&#10;              getScreenYPosition(fpoint.getClose(), Max, Min)&#10;                - getScreenYPosition(fpoint.getOpen(), Max, Min),&#10;              1, 1);&#10;            g.setColor(FConfig.CandleColorDown2);&#10;            g.drawRoundRect(this.getScreenXPositionFromPoint(i) - CandleWidth,&#10;              this.getScreenYPosition(fpoint.getOpen(), Max, Min), CandleWidth * 2 + 1,&#10;              getScreenYPosition(fpoint.getClose(), Max, Min)&#10;                - getScreenYPosition(fpoint.getOpen(), Max, Min),&#10;              1, 1);&#10;            g.setColor(FConfig.CandleColorDown);&#10;            g.drawLine(this.getScreenXPositionFromPoint(i),&#10;              this.getScreenYPosition(fpoint.getClose(), Max, Min), getScreenXPositionFromPoint(i),&#10;              getScreenYPosition(fpoint.getMinimum(), Max, Min));&#10;            if (fpoint.getClose() == fpoint.getOpen()) {&#10;              g.drawLine(this.getScreenXPositionFromPoint(i) - CandleWidth,&#10;                this.getScreenYPosition(fpoint.getOpen(), Max, Min),&#10;                this.getScreenXPositionFromPoint(i) + CandleWidth,&#10;                getScreenYPosition(fpoint.getClose(), Max, Min));&#10;            }&#10;          } else {&#10;            g.setColor(FConfig.CandleColorUp);&#10;            g.drawLine(this.getScreenXPositionFromPoint(i),&#10;              this.getScreenYPosition(fpoint.getMaximum(), Max, Min), getScreenXPositionFromPoint(i),&#10;              getScreenYPosition(fpoint.getClose(), Max, Min));&#10;            g.fillRoundRect(this.getScreenXPositionFromPoint(i) - CandleWidth,&#10;              this.getScreenYPosition(fpoint.getClose(), Max, Min), CandleWidth * 2,&#10;              getScreenYPosition(fpoint.getOpen(), Max, Min)&#10;                - getScreenYPosition(fpoint.getClose(), Max, Min),&#10;              1, 1);&#10;            g.setColor(FConfig.CandleColorUp2);&#10;            g.drawRoundRect(this.getScreenXPositionFromPoint(i) - CandleWidth,&#10;              this.getScreenYPosition(fpoint.getClose(), Max, Min), CandleWidth * 2,&#10;              getScreenYPosition(fpoint.getOpen(), Max, Min)&#10;                - getScreenYPosition(fpoint.getClose(), Max, Min),&#10;              1, 1);&#10;            g.setColor(FConfig.CandleColorUp);&#10;            g.drawLine(this.getScreenXPositionFromPoint(i),&#10;              this.getScreenYPosition(fpoint.getOpen(), Max, Min), getScreenXPositionFromPoint(i),&#10;              getScreenYPosition(fpoint.getMinimum(), Max, Min));&#10;            if (fpoint.getClose() == fpoint.getOpen()) {&#10;              g.drawLine(this.getScreenXPositionFromPoint(i) - CandleWidth,&#10;                this.getScreenYPosition(fpoint.getOpen(), Max, Min),&#10;                this.getScreenXPositionFromPoint(i) + CandleWidth,&#10;                getScreenYPosition(fpoint.getClose(), Max, Min));&#10;            }&#10;          }&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  private void plotBarChart(ChartItem currentChart) {&#10;&#10;    double Max = currentChart.getChartBound().getUpperStockBound();&#10;    double Min = currentChart.getChartBound().getLowerStockBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(FConfig.BarColor);&#10;&#10;    int BarWidth = 1;&#10;    if (resolution &gt;= 3 &amp;&amp; resolution &lt;= 4) {&#10;      BarWidth = 1;&#10;    } else if (resolution &gt;= 5 &amp;&amp; resolution &lt;= 6) {&#10;      BarWidth = 2;&#10;    } else if (resolution &gt;= 7 &amp;&amp; resolution &lt;= 8) {&#10;      BarWidth = 3;&#10;    } else if (resolution &gt;= 9 &amp;&amp; resolution &lt;= 10) {&#10;      BarWidth = 4;&#10;    } else if (resolution &gt;= 11) {&#10;      BarWidth = (int) (resolution / 2d);&#10;    }&#10;    for (int i = startDisplayIndex; i &lt;= endDisplayIndex; i++) {&#10;      StockData fpoint = currentChart.getChartData().getData().get(i);&#10;      if (!fpoint.isIntraDayMarked()) {&#10;        if (fpoint.isValid()) {&#10;          g.drawLine(this.getScreenXPositionFromPoint(i),&#10;            this.getScreenYPosition(fpoint.getMaximum(), Max, Min), getScreenXPositionFromPoint(i),&#10;            getScreenYPosition(fpoint.getMinimum(), Max, Min));&#10;          g.drawLine(this.getScreenXPositionFromPoint(i) - BarWidth,&#10;            this.getScreenYPosition(fpoint.getOpen(), Max, Min), getScreenXPositionFromPoint(i),&#10;            getScreenYPosition(fpoint.getOpen(), Max, Min));&#10;          g.drawLine(this.getScreenXPositionFromPoint(i),&#10;            this.getScreenYPosition(fpoint.getClose(), Max, Min),&#10;            getScreenXPositionFromPoint(i) + BarWidth, getScreenYPosition(fpoint.getClose(), Max, Min));&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  private void plotBollingerBand(ChartItem currentChart) {&#10;&#10;    // System.out.println(&quot;Line : &quot; + startDisplayIndex + &quot; : &quot; +&#10;    // endDisplayIndex);&#10;    double Max = currentChart.getChartBound().getUpperStockBound();&#10;    double Min = currentChart.getChartBound().getLowerStockBound();&#10;&#10;    int N = currentChart.getChartData().getfTAconfig().bbN;&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    AnalyticalResult fTApoint1 = null;&#10;    AnalyticalResult fTApoint2 = null;&#10;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      // System.out.println(&quot;pp: &quot; + i);&#10;      fTApoint1 = currentChart.getChartData().getAnalyticalResults().get(i);&#10;      fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(i - 1);&#10;&#10;      if (fTApoint1 != null &amp;&amp; fTApoint2 != null &amp;&amp; fTApoint1.isValid() &amp;&amp; fTApoint2.isValid()) {&#10;        try {&#10;          // System.out.println(&quot;pp: &quot; + i +&quot; ---------------------&quot;);&#10;          int y1, y2;&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = this.getScreenXPositionFromPoint(i - 1);&#10;&#10;          // plot UB line&#10;          g.setColor(FConfig.BollingerBandColor);&#10;          y1 = this.getScreenYPosition(fTApoint1.getUB(), Max, Min);&#10;          y2 = getScreenYPosition(fTApoint2.getUB(), Max, Min);&#10;          // System.out.println(x1 + &quot; : &quot; + y1 + &quot; : &quot; + x2 + &quot; : &quot; +&#10;          // y2 + &quot; plot&quot;);&#10;          if (i &gt; N) {&#10;            g.drawLine(x1, y1, x2, y2);&#10;          }&#10;&#10;          // plot LB line&#10;          g.setColor(FConfig.BollingerBandColor);&#10;          y1 = this.getScreenYPosition(fTApoint1.getLB(), Max, Min);&#10;          y2 = getScreenYPosition(fTApoint2.getLB(), Max, Min);&#10;          if (i &gt; N) {&#10;            g.drawLine(x1, y1, x2, y2);&#10;          }&#10;&#10;        } catch (Exception ee) {&#10;          ee.printStackTrace();&#10;        }&#10;      }&#10;&#10;    }&#10;&#10;  }&#10;&#10;  private void plotOBV(ChartItem currentChart) {&#10;&#10;    double Max = currentChart.getChartBound().getUpperOBVBound();&#10;    double Min = currentChart.getChartBound().getLowerOBVBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    AnalyticalResult fTApoint1 = null;&#10;    AnalyticalResult fTApoint2 = null;&#10;&#10;    g.setColor(FConfig.OBVColor);&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      fTApoint1 = currentChart.getChartData().getAnalyticalResults().get(i);&#10;      fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(i - 1);&#10;&#10;      if (fTApoint1 != null &amp;&amp; fTApoint2 != null &amp;&amp; fTApoint1.isValid() &amp;&amp; fTApoint2.isValid()) {&#10;        try {&#10;&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = this.getScreenXPositionFromPoint(i - 1);&#10;&#10;          // plot OBV&#10;          int y1 = this.getScreenYPosition(fTApoint1.getOBV(), Max, Min);&#10;          int y2 = getScreenYPosition(fTApoint2.getOBV(), Max, Min);&#10;          drawLineWithWidth(g, x1, y1, x2, y2, 2f);&#10;&#10;        } catch (Exception ee) {&#10;          ee.printStackTrace();&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  private void plotMACD(ChartItem currentChart) {&#10;    // System.out.println(&quot;Line : &quot; + startDisplayIndex + &quot; : &quot; +&#10;    // endDisplayIndex);&#10;    double Max = currentChart.getChartBound().getUpperMACDBound();&#10;    double Min = currentChart.getChartBound().getLowerMACDBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    AnalyticalResult fTApoint1 = null;&#10;    AnalyticalResult fTApoint2 = null;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      fTApoint1 = currentChart.getChartData().getAnalyticalResults().get(i);&#10;      fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(i - 1);&#10;&#10;      if (fTApoint1 != null &amp;&amp; fTApoint2 != null &amp;&amp; fTApoint1.isValid() &amp;&amp; fTApoint2.isValid()) {&#10;        try {&#10;&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = this.getScreenXPositionFromPoint(i - 1);&#10;&#10;          // plot MACD1&#10;          int y1 = this.getScreenYPosition(fTApoint1.getMACD1(), Max, Min);&#10;          int y2 = getScreenYPosition(fTApoint2.getMACD1(), Max, Min);&#10;&#10;          g.setColor(FConfig.MACDColor1);&#10;          g.drawLine(x1, y1, x2, y2);&#10;&#10;          // plot MACD2&#10;          y1 = this.getScreenYPosition(fTApoint1.getMACD2(), Max, Min);&#10;          y2 = getScreenYPosition(fTApoint2.getMACD2(), Max, Min);&#10;&#10;          g.setColor(FConfig.MACDColor2);&#10;          g.drawLine(x1, y1, x2, y2);&#10;&#10;          y1 = this.getScreenYPosition(fTApoint1.getMACDdiff(), Max, Min);&#10;          y2 = this.getScreenYPosition(0, Max, Min);&#10;          g.setColor(FConfig.MACDColor3);&#10;          g.drawLine(x1, y1, x1, y2);&#10;        } catch (Exception ee) {&#10;          ee.printStackTrace();&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  private void plotWILLIAM_R(ChartItem currentChart) {&#10;&#10;    double Max = currentChart.getChartBound().getUpperWilliamRBound();&#10;    double Min = currentChart.getChartBound().getLowerWilliamRBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    AnalyticalResult fTApoint1 = null;&#10;    AnalyticalResult fTApoint2 = null;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      fTApoint1 = currentChart.getChartData().getAnalyticalResults().get(i);&#10;      fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(i - 1);&#10;&#10;      if (fTApoint1 != null &amp;&amp; fTApoint2 != null &amp;&amp; fTApoint1.isValid() &amp;&amp; fTApoint2.isValid()) {&#10;        try {&#10;&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = this.getScreenXPositionFromPoint(i - 1);&#10;&#10;          // plot %R&#10;          int y1 = this.getScreenYPosition(fTApoint1.getR(), Max, Min);&#10;          int y2 = getScreenYPosition(fTApoint2.getR(), Max, Min);&#10;          g.setColor(FConfig.WilliamRColor);&#10;          drawLineWithWidth(g, x1, y1, x2, y2, 3f);&#10;        } catch (Exception ee) {&#10;          ee.printStackTrace();&#10;        }&#10;      }&#10;    }&#10;&#10;    g.setColor(Color.red);&#10;    int x1 = this.getScreenXPositionFromPoint(startDisplayIndex);&#10;    int x2 = getScreenXPositionFromPoint(endDisplayIndex);&#10;    int y1 = this.getScreenYPosition(50, Max, Min);&#10;    // this.drawDotLine(g,x1,y1,x2,y1);&#10;    g.drawLine(x1, y1, x2, y1);&#10;&#10;  }&#10;&#10;  private void plotSTC(ChartItem currentChart) {&#10;    double Max = currentChart.getChartBound().getUpperSTCBound();&#10;    double Min = currentChart.getChartBound().getLowerSTCBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    AnalyticalResult fTApoint1 = null;&#10;    AnalyticalResult fTApoint2 = null;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      fTApoint1 = currentChart.getChartData().getAnalyticalResults().get(i);&#10;      fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(i - 1);&#10;      if (fTApoint1 != null &amp;&amp; fTApoint2 != null &amp;&amp; fTApoint1.isValid() &amp;&amp; fTApoint2.isValid()) {&#10;        try {&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = this.getScreenXPositionFromPoint(i - 1);&#10;&#10;          // plot %K&#10;          int y1 = this.getScreenYPosition(fTApoint1.getK(), Max, Min);&#10;          int y2 = getScreenYPosition(fTApoint2.getK(), Max, Min);&#10;          g.setColor(FConfig.STCColorK);&#10;          drawLineWithWidth(g, x1, y1, x2, y2, 3f);&#10;&#10;          // plot %D&#10;          y1 = this.getScreenYPosition(fTApoint1.getD(), Max, Min);&#10;          y2 = getScreenYPosition(fTApoint2.getD(), Max, Min);&#10;          g.setColor(FConfig.STCColorD);&#10;          drawLineWithWidth(g, x1, y1, x2, y2, 3f);&#10;        } catch (Exception ee) {&#10;          ee.printStackTrace();&#10;        }&#10;      }&#10;    }&#10;&#10;    g.setColor(Color.red);&#10;    int x1 = this.getScreenXPositionFromPoint(startDisplayIndex);&#10;    int x2 = getScreenXPositionFromPoint(endDisplayIndex);&#10;    int y1 = this.getScreenYPosition(80, Max, Min);&#10;    int y2 = getScreenYPosition(20, Max, Min);&#10;    g.drawLine(x1, y1, x2, y1);&#10;    g.drawLine(x1, y2, x2, y2);&#10;&#10;  }&#10;&#10;  private void plotRSI(ChartItem currentChart) {&#10;    // System.out.println(&quot;Line : &quot; + startDisplayIndex + &quot; : &quot; +&#10;    // endDisplayIndex);&#10;    double Max = currentChart.getChartBound().getUpperRSIBound();&#10;    double Min = currentChart.getChartBound().getLowerRSIBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    AnalyticalResult fTApoint1 = null;&#10;    AnalyticalResult fTApoint2 = null;&#10;    int lastValidPoint = 0;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      fTApoint1 = currentChart.getChartData().getAnalyticalResults().get(i);&#10;      fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(i - 1);&#10;      if (fTApoint2.isValid()) {&#10;        lastValidPoint = i - 1;&#10;      } else {&#10;        fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(lastValidPoint);&#10;      }&#10;      // plot the RSI line&#10;      if (fTApoint1 != null &amp;&amp; fTApoint2 != null &amp;&amp; fTApoint1.isValid() &amp;&amp; fTApoint2.isValid()) {&#10;        try {&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = this.getScreenXPositionFromPoint(lastValidPoint);&#10;          int y1 = this.getScreenYPosition(fTApoint1.getRSI(), Max, Min);&#10;          int y2 = getScreenYPosition(fTApoint2.getRSI(), Max, Min);&#10;          g.setColor(FConfig.RSIColor);&#10;          drawLineWithWidth(g, x1, y1 , x2, y2 , 3f);&#10;          lastValidPoint = i;&#10;        } catch (Exception ee) {&#10;        }&#10;      }&#10;    }&#10;    // plot the parellel line.&#10;    g.setColor(Color.red);&#10;    int x1 = this.getScreenXPositionFromPoint(startDisplayIndex);&#10;    int x2 = getScreenXPositionFromPoint(endDisplayIndex);&#10;    int y1 = this.getScreenYPosition(70, Max, Min);&#10;    int y2 = getScreenYPosition(30, Max, Min);&#10;    drawDotLine(g, x1, y1, x2, y1);&#10;    drawDotLine(g, x1, y2, x2, y2);&#10;&#10;  }&#10;&#10;  private void plotMovingAverage(ChartItem currentChart) {&#10;&#10;    double Max = currentChart.getChartBound().getUpperStockBound();&#10;    double Min = currentChart.getChartBound().getLowerStockBound();&#10;    int N1, N2, N3;&#10;&#10;    if (currentChart.getChartType() == ChartType.SIMPLE_MOVING_AVERAGE) {&#10;      N1 = currentChart.getChartData().getfTAconfig().SMAN1;&#10;      N2 = currentChart.getChartData().getfTAconfig().SMAN2;&#10;      N3 = currentChart.getChartData().getfTAconfig().SMAN3;&#10;&#10;    } else if (currentChart.getChartType() == ChartType.WEIGHTED_MOVING_AVERAGE) {&#10;      N1 = currentChart.getChartData().getfTAconfig().WMAN1;&#10;      N2 = currentChart.getChartData().getfTAconfig().WMAN2;&#10;      N3 = currentChart.getChartData().getfTAconfig().WMAN3;&#10;    } else if (currentChart.getChartType() == ChartType.EXPONENTIAL_MOVING_AVERAGE) {&#10;      N1 = 0;&#10;      N2 = 0;&#10;      N3 = 0;&#10;    } else {&#10;      N1 = 0;&#10;      N2 = 0;&#10;      N3 = 0;&#10;    }&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(currentChart.getFirstColor());&#10;&#10;    AnalyticalResult fTApoint1 = null;&#10;    AnalyticalResult fTApoint2 = null;&#10;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      fTApoint1 = currentChart.getChartData().getAnalyticalResults().get(i);&#10;      fTApoint2 = currentChart.getChartData().getAnalyticalResults().get(i - 1);&#10;&#10;      if (fTApoint1 != null &amp;&amp; fTApoint2 != null &amp;&amp; fTApoint1.isValid() &amp;&amp; fTApoint2.isValid()) {&#10;        try {&#10;          int y1, y2;&#10;          int x1 = this.getScreenXPositionFromPoint(i);&#10;          int x2 = this.getScreenXPositionFromPoint(i - 1);&#10;&#10;          // plot MA1 line&#10;          g.setColor(FConfig.MAColor1);&#10;          y1 = this.getScreenYPosition(fTApoint1.getMA1(), Max, Min);&#10;          y2 = getScreenYPosition(fTApoint2.getMA1(), Max, Min);&#10;          if (i &gt; N1) {&#10;            drawLineWithWidth(g, x1, y1, x2, y2, 2f);&#10;          }&#10;&#10;          // plot MA2 line&#10;          g.setColor(FConfig.MAColor2);&#10;          y1 = this.getScreenYPosition(fTApoint1.getMA2(), Max, Min);&#10;          y2 = getScreenYPosition(fTApoint2.getMA2(), Max, Min);&#10;          if (i &gt; N2) {&#10;            drawLineWithWidth(g, x1, y1, x2, y2, 2f);&#10;          }&#10;&#10;          // plot MA3 line&#10;          g.setColor(FConfig.MAColor3);&#10;          y1 = this.getScreenYPosition(fTApoint1.getMA3(), Max, Min);&#10;          y2 = getScreenYPosition(fTApoint2.getMA3(), Max, Min);&#10;          if (i &gt; N3) {&#10;            drawLineWithWidth(g, x1, y1, x2, y2, 2f);&#10;          }&#10;&#10;        } catch (Exception ee) {&#10;          ee.printStackTrace();&#10;        }&#10;      }&#10;&#10;    }&#10;&#10;  }&#10;&#10;  private void plotLineChart(ChartItem currentChart) {&#10;&#10;    double Max = currentChart.getChartBound().getUpperStockBound();&#10;    double Min = currentChart.getChartBound().getLowerStockBound();&#10;&#10;    Graphics g = getScreenImage().getGraphics();&#10;    g.setColor(FConfig.LineColor);&#10;&#10;    StockData fpoint1 = null;&#10;    StockData fpoint2 = null;&#10;    int lastValidPoint = 0;&#10;    for (int i = startDisplayIndex + 1; i &lt;= endDisplayIndex; i++) {&#10;      fpoint1 = currentChart.getChartData().getData().get(i);&#10;      fpoint2 = currentChart.getChartData().getData().get(i - 1);&#10;      if (fpoint2.isValid()) {&#10;        lastValidPoint = i - 1;&#10;      } else {&#10;        fpoint2 = currentChart.getChartData().getData().get(lastValidPoint);&#10;      }&#10;      if (fpoint1 != null &amp;&amp; fpoint2 != null &amp;&amp; fpoint1.isValid() &amp;&amp; fpoint2.isValid()) {&#10;        try {&#10;          int x1 = getScreenXPositionFromPoint(i);&#10;          int x2 = getScreenXPositionFromPoint(lastValidPoint);&#10;          int y1 = getScreenYPosition(fpoint1.getClose(), Max, Min);&#10;          int y2 = getScreenYPosition(fpoint2.getClose(), Max, Min);&#10;&#10;          int y0 = getScreenYPosition(Min, Max, Min);&#10;          drawLineWithWidth(g, x1, y1, x2, y2, 3f);&#10;&#10;          // g.setColor(Color.red);&#10;          // g.fillRect(x1, y1, Math.abs(x2-x1),y0-y1);&#10;          lastValidPoint = i;&#10;        } catch (Exception ee) {&#10;          log.warning(&quot;Error plotting line chart at index &quot; + i + &quot;: &quot; + ee.getMessage());&#10;        }&#10;      }&#10;&#10;    }&#10;&#10;  }&#10;&#10;  // only parallel or vertical line can be plotted.&#10;  private void drawDotLine(Graphics g, int x1, int y1, int x2, int y2) {&#10;&#10;    if (x1 == x2) {&#10;      /* Y axis */&#10;      int p1, p2;&#10;      p1 = Math.min(y1, y2);&#10;      p2 = Math.max(y1, y2);&#10;      for (int i = p1; i &lt;= p2 - 2; i = i + 4) {&#10;        g.drawLine(x1, i, x1, i + 1);&#10;      }&#10;    } else if (y1 == y2) {&#10;      /* X axis */&#10;      int p1, p2;&#10;      p1 = Math.min(x1, x2);&#10;      p2 = Math.max(x1, x2);&#10;      for (int i = p1; i &lt;= p2 - 2; i = i + 4) {&#10;        g.drawLine(i, y1, i + 1, y1);&#10;      }&#10;    }&#10;&#10;  }&#10;&#10;  private void plotXAxis(ChartItem currentChart, boolean isLabel) {&#10;    // Use consistent grid color&#10;    if (gridColor == null) {&#10;      gridColor = new Color(230, 230, 235); // Match Y-axis grid color&#10;    }&#10;    int dpoint = endDisplayIndex;&#10;    Graphics g = getAllScreenImage().getGraphics();&#10;    Graphics gg = getScreenImage().getGraphics();&#10;&#10;    // when the resolution is small, set the font size to some.&#10;    if (resolution &lt;= 4) {&#10;      g.setFont(new Font(&quot;SansSerif&quot;, Font.PLAIN, 11));&#10;      gg.setFont(new Font(&quot;SansSerif&quot;, Font.PLAIN, 11));&#10;    }&#10;&#10;    if (currentChart.isShowXaxis()) {&#10;      if (currentChart.getChartData().dataInterval == DataInterval.DAILY) {&#10;        for (int i = startDisplayIndex; i &lt; dpoint; i++) {&#10;          if (i &gt;= currentChart.getChartData().getData().size()) {&#10;            // log.warning(&quot;ChartData: &quot; +&#10;            // currentChart.getChartData().getData().size() + &quot;&#10;            // dpoint: &quot; + dpoint);&#10;            continue;&#10;          }&#10;          int j = Math.max(i - 1, startDisplayIndex);&#10;          StockData fpoint = currentChart.getChartData().getData().get(i);&#10;          StockData fpoint2 = currentChart.getChartData().getData().get(j);&#10;          if (fpoint.getMonth() != fpoint2.getMonth()) {&#10;            if (!isLabel) {&#10;              gg.setColor(gridColor);&#10;              // Draw solid grid lines for professional look&#10;              if (gg instanceof Graphics2D) {&#10;                Graphics2D g2d = (Graphics2D) gg;&#10;                g2d.setStroke(new BasicStroke(0.5f));&#10;                g2d.drawLine(getScreenXPositionFromPoint(i), topSpace, getScreenXPositionFromPoint(i),&#10;                  topSpace + getYAxisWidth());&#10;                g2d.setStroke(new BasicStroke(1.0f));&#10;              } else {&#10;                drawDotLine(gg, getScreenXPositionFromPoint(i), topSpace, getScreenXPositionFromPoint(i),&#10;                  topSpace + getYAxisWidth());&#10;              }&#10;              continue;&#10;            }&#10;&#10;            g.setColor(new Color(80, 80, 80)); // Professional dark gray for tick marks&#10;            g.drawLine(getScreenXPositionFromPoint(i), topSpace + getYAxisWidth(),&#10;              getScreenXPositionFromPoint(i), topSpace + getYAxisWidth() + 2);&#10;            String dateMY = FormatUtil.formatMonth(fpoint.getDate());&#10;            if (bottomSpace &gt; 8) {&#10;              g.drawString(dateMY, getScreenXPositionFromPoint(i) - 10, topSpace + getYAxisWidth() + 14);&#10;&#10;              if (fpoint.getMonth() == 1)&#10;                g.drawString(fpoint.getYear() + &quot;&quot;, getScreenXPositionFromPoint(i) - 10,&#10;                  topSpace + getYAxisWidth() + 30);&#10;&#10;              // if (fpoint.getMonth())&#10;            }&#10;          }&#10;        }&#10;      } else if (currentChart.getChartData().dataInterval == DataInterval.WEEKLY) {&#10;        for (int i = startDisplayIndex; i &lt; dpoint; i++) {&#10;          int j = Math.max(i - 1, startDisplayIndex);&#10;          StockData fpoint = currentChart.getChartData().getData().get(i);&#10;          StockData fpoint2 = currentChart.getChartData().getData().get(j);&#10;          if (fpoint.getMonth() != fpoint2.getMonth() &amp;&amp; fpoint.getMonth() % 3 == 1) {&#10;            if (!isLabel) {&#10;              gg.setColor(gridColor);&#10;              drawDotLine(gg, getScreenXPositionFromPoint(i), topSpace, getScreenXPositionFromPoint(i),&#10;                topSpace + getYAxisWidth());&#10;              continue;&#10;            }&#10;&#10;            g.setColor(Color.black);&#10;            g.drawLine(getScreenXPositionFromPoint(i), topSpace + getYAxisWidth(),&#10;              getScreenXPositionFromPoint(i), topSpace + getYAxisWidth() + 4);&#10;            String dateMY = fpoint.getMonth() + &quot;-&quot; + fpoint.getYear();&#10;            if (bottomSpace &gt; 8) {&#10;              g.drawString(dateMY, getScreenXPositionFromPoint(i), topSpace + getYAxisWidth() + 11);&#10;            }&#10;          }&#10;        }&#10;      } else if (currentChart.getChartData().dataInterval == DataInterval.MONTHLY) {&#10;        for (int i = startDisplayIndex; i &lt; dpoint; i++) {&#10;          // System.out.println(&quot;ADFA&quot;);&#10;          int j = Math.max(i - 1, startDisplayIndex);&#10;          StockData fpoint = currentChart.getChartData().getData().get(i);&#10;          StockData fpoint2 = currentChart.getChartData().getData().get(j);&#10;          if (fpoint.getYear() != fpoint2.getYear()) {&#10;            if (!isLabel) {&#10;              gg.setColor(gridColor);&#10;              drawDotLine(gg, getScreenXPositionFromPoint(i), topSpace, getScreenXPositionFromPoint(i),&#10;                topSpace + getYAxisWidth());&#10;              continue;&#10;            }&#10;&#10;            g.setColor(Color.black);&#10;            g.drawLine(getScreenXPositionFromPoint(i), topSpace + getYAxisWidth(),&#10;              getScreenXPositionFromPoint(i), topSpace + getYAxisWidth() + 4);&#10;            String dateY = String.valueOf(fpoint.getYear());&#10;            if (bottomSpace &gt; 8) {&#10;              g.drawString(dateY, getScreenXPositionFromPoint(i), topSpace + getYAxisWidth() + 11);&#10;            }&#10;          }&#10;        }&#10;      } else if (currentChart.getChartData().dataInterval == DataInterval.INTRADAY) {&#10;        for (int i = startDisplayIndex; i &lt; dpoint; i++) {&#10;          int j = Math.max(i - 1, startDisplayIndex);&#10;          StockData fpoint = currentChart.getChartData().getData().get(i);&#10;          if (fpoint.getMinute() == 0 &amp;&amp; fpoint.getHour() != 0) {&#10;            if (!isLabel) {&#10;              gg.setColor(gridColor);&#10;              drawDotLine(gg, getScreenXPositionFromPoint(i), topSpace, getScreenXPositionFromPoint(i),&#10;                topSpace + getYAxisWidth());&#10;              continue;&#10;            }&#10;&#10;            g.setColor(Color.black);&#10;            g.drawLine(getScreenXPositionFromPoint(i), topSpace + getYAxisWidth(),&#10;              getScreenXPositionFromPoint(i), topSpace + getYAxisWidth() + 4);&#10;&#10;            String dateTime = fpoint.getHour() + &quot;:00&quot;;&#10;            if (bottomSpace &gt; 8) {&#10;              g.drawString(dateTime, getScreenXPositionFromPoint(i), topSpace + getYAxisWidth() + 11);&#10;            }&#10;          }&#10;        }&#10;      }&#10;    }&#10;&#10;  }&#10;&#10;  private void drawCompareTable() {&#10;    ChartItem lcchart = getLeftChart();&#10;    if (lcchart != null &amp;&amp; lcchart.getChartType() == ChartType.PERCENTAGE) {&#10;      // get the number of Percentage chart.....&#10;      int count = 0;&#10;      for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;        ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;        if (cchart.getChartType() == ChartType.PERCENTAGE) {&#10;          count++;&#10;        }&#10;      }&#10;      // draw the table.&#10;      int x1 = getSize().width - rightSpace - 150;&#10;      int y1 = topSpace + 5;&#10;      int ww = 145;&#10;      int hh = 14 * count + 6;&#10;      if (actionCommand.getCurrentMousePoint().x &gt; x1 &amp;&amp; actionCommand.getCurrentMousePoint().x &lt; (x1 + ww)&#10;        &amp;&amp; actionCommand.getCurrentMousePoint().y &gt; y1&#10;        &amp;&amp; actionCommand.getCurrentMousePoint().y &lt; (y1 + hh)) {&#10;        return;&#10;      }&#10;      Graphics gg = getAllScreenImage().getGraphics();&#10;      gg.setColor(new Color(240, 240, 240));&#10;      // gg.fill3DRect(x1, y1, ww, hh, true);&#10;      int lcount = 1;&#10;      for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;        ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;        if (cchart.getChartType() == ChartType.PERCENTAGE) {&#10;&#10;          gg.setFont(FConfig.DEFAULT_FONT);&#10;          String Name = cchart.getChartData().getName();&#10;          String slabel = cchart.getChartData().getCode() + &quot; &quot; + Name;&#10;          int labelWith = gg.getFontMetrics().charsWidth(slabel.toCharArray(), 0, slabel.length());&#10;          // gg.setColor(new Color(128, 128, 128));&#10;          // gg.fill3DRect(getSize().width - rightSpace - labelWith +&#10;          // 5, topSpace + 5 + 3 + (lcount - 1) * 18, labelWith, 19,&#10;          // true);&#10;          gg.setColor(cchart.getFirstColor());&#10;          gg.drawString(slabel, getSize().width - rightSpace - labelWith + 5, topSpace + 5 + 3 + lcount * 17);&#10;          lcount++;&#10;        }&#10;      }&#10;&#10;    }&#10;&#10;  }&#10;&#10;  // draw the chart name .&#10;  private void drawLabel(ChartItem currentChart) {&#10;&#10;    // Skip drawing labels for overlay indicators (they share the main chart panel)&#10;    // These indicators don't get their own label since they overlay on the price chart&#10;    if (currentChart.getChartType() == ChartType.SIMPLE_MOVING_AVERAGE ||&#10;        currentChart.getChartType() == ChartType.WEIGHTED_MOVING_AVERAGE ||&#10;        currentChart.getChartType() == ChartType.EXPONENTIAL_MOVING_AVERAGE ||&#10;        currentChart.getChartType() == ChartType.BOLLINGERBAND) {&#10;      return; // Don't draw label for overlay indicators&#10;    }&#10;&#10;    Graphics g = getAllScreenImage().getGraphics();&#10;&#10;    // Use professional font with anti-aliasing&#10;    g.setFont(new Font(&quot;SansSerif&quot;, Font.BOLD, FConfig.SCREEN_FONT_SIZE));&#10;    if (g instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) g;&#10;      g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);&#10;    }&#10;&#10;    if (currentChart.getAxisBar() == AxisType.LEFTAXIS) {&#10;      if (currentChart.getChartType() == ChartType.BAR || currentChart.getChartType() == ChartType.LINE&#10;        || currentChart.getChartType() == ChartType.CANDLE) {&#10;        g.setColor(currentChart.getFirstColor());&#10;        String cname = &quot;&quot;;&#10;        cname = currentChart.getChartData().getName();&#10;        g.drawString(currentChart.getChartData().getCode() + &quot; &quot; + cname, leftSpace + 5,&#10;          FConfig.SCREEN_FONT_SIZE + 10);&#10;      }&#10;&#10;      if (currentChart.getChartType() == ChartType.PERCENTAGE) {&#10;        g.setColor(currentChart.getFirstColor());&#10;        StockData fpoint = currentChart.getChartData().getData().get(startDisplayIndex);&#10;        String sdate = &quot;&quot;;&#10;        if (currentChart.getChartData().dataInterval == DataInterval.INTRADAY) {&#10;          sdate = ChartLabelText.getLabel(22, language) + &quot; : &quot; + FormatUtil.formatTime(fpoint.getHour(), fpoint.getMinute());&#10;        } else {&#10;          sdate = ChartLabelText.getLabel(21, language) + &quot; : &quot; + fpoint.getDay() + &quot;-&quot; + fpoint.getMonth() + &quot;-&quot;&#10;            + fpoint.getYear();&#10;        }&#10;        g.drawString(sdate, leftSpace + 5, FConfig.SCREEN_FONT_SIZE + 10);&#10;      }&#10;&#10;    }&#10;&#10;    // Use slightly smaller, regular weight font for indicator labels&#10;    g.setFont(new Font(&quot;SansSerif&quot;, Font.PLAIN, FConfig.SCREEN_FONT_SIZE - 2));&#10;&#10;    if (currentChart.getChartType() == ChartType.VOLUME) {&#10;      g.setColor(new Color(60, 60, 60)); // Professional dark gray&#10;      g.drawString(ChartLabelText.getLabel(9, language), leftSpace + 5, FConfig.SCREEN_FONT_SIZE + 10);&#10;    } else if (currentChart.getChartType() == ChartType.MACD) {&#10;      String tempString;&#10;      tempString = ChartLabelText.getLabel(20, language);&#10;      tempString = tempString + &quot; (&quot; + currentChart.getChartData().getfTAconfig().MACDLEMA + &quot;-&quot;&#10;        + currentChart.getChartData().getfTAconfig().MACDSEMA + &quot;)&quot;;&#10;      g.setColor(FConfig.MACDColor1);&#10;      g.drawString(tempString, leftSpace + 5, FConfig.SCREEN_FONT_SIZE + 10);&#10;      tempString = &quot;EMA(&quot; + currentChart.getChartData().getfTAconfig().MACDAEMA + &quot;)&quot;;&#10;      g.setColor(FConfig.MACDColor2);&#10;      g.drawString(tempString, leftSpace + 5 + 110, FConfig.SCREEN_FONT_SIZE + 10);&#10;      tempString = &quot;DIFF&quot;;&#10;      g.setColor(FConfig.MACDColor3);&#10;      g.drawString(tempString, leftSpace + 100, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;    } else if (currentChart.getChartType() == ChartType.EXPONENTIAL_MOVING_AVERAGE) {&#10;      String tempString;&#10;      g.setColor(FConfig.MAColor1);&#10;      tempString = &quot;EMA(&quot; + currentChart.getChartData().getfTAconfig().EMA1 + &quot;)&quot;;&#10;      g.drawString(tempString, leftSpace + 5, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;      tempString = &quot;EMA(&quot; + currentChart.getChartData().getfTAconfig().EMA2 + &quot;)&quot;;&#10;      g.setColor(FConfig.MAColor2);&#10;      g.drawString(tempString, leftSpace + 5 + 110, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;      tempString = &quot;EMA(&quot; + currentChart.getChartData().getfTAconfig().EMA3 + &quot;)&quot;;&#10;      g.setColor(FConfig.MAColor3);&#10;      g.drawString(tempString, leftSpace + 5 + 220, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;    } else if (currentChart.getChartType() == ChartType.SIMPLE_MOVING_AVERAGE) {&#10;      String tempString;&#10;      g.setColor(FConfig.MAColor1);&#10;      tempString = &quot;SMA(&quot; + currentChart.getChartData().getfTAconfig().SMAN1 + &quot;)&quot;;&#10;      g.drawString(tempString, leftSpace + 5, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;      tempString = &quot;SMA(&quot; + currentChart.getChartData().getfTAconfig().SMAN2 + &quot;)&quot;;&#10;      g.setColor(FConfig.MAColor2);&#10;      g.drawString(tempString, leftSpace + 5 + 110, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;      tempString = &quot;SMA(&quot; + currentChart.getChartData().getfTAconfig().SMAN3 + &quot;)&quot;;&#10;      g.setColor(FConfig.MAColor3);&#10;      g.drawString(tempString, leftSpace + 5 + 220, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;    } else if (currentChart.getChartType() == ChartType.WEIGHTED_MOVING_AVERAGE) {&#10;      String tempString;&#10;      g.setColor(FConfig.MAColor1);&#10;      tempString = &quot;WMA(&quot; + currentChart.getChartData().getfTAconfig().WMAN1 + &quot;)&quot;;&#10;      g.drawString(tempString, leftSpace + 5, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;      tempString = &quot;WMA(&quot; + currentChart.getChartData().getfTAconfig().WMAN2 + &quot;)&quot;;&#10;      g.setColor(FConfig.MAColor2);&#10;      g.drawString(tempString, leftSpace + 5 + 110, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;      tempString = &quot;WMA(&quot; + currentChart.getChartData().getfTAconfig().WMAN3 + &quot;)&quot;;&#10;      g.setColor(FConfig.MAColor3);&#10;      g.drawString(tempString, leftSpace + 5 + 220, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;    } else if (currentChart.getChartType() == ChartType.BOLLINGERBAND) {&#10;      String tempString;&#10;      g.setColor(FConfig.BollingerBandColor);&#10;      tempString = &quot;SMA(&quot; + currentChart.getChartData().getfTAconfig().bbN + &quot;)&quot;;&#10;      tempString = tempString + &quot;  &quot; + ChartLabelText.getLabel(22, language) + &quot;(&quot;&#10;        + currentChart.getChartData().getfTAconfig().bbDevation + &quot;)&quot;;&#10;      g.drawString(tempString, leftSpace + 5, (FConfig.SCREEN_FONT_SIZE + 10) * 2);&#10;    } else if (currentChart.getChartType() == ChartType.RSI) {&#10;      String tempString;&#10;      tempString = ChartLabelText.getLabel(17, language) + &quot; (&quot; + currentChart.getChartData().getfTAconfig().RSIPeriod + &quot;)&quot;;&#10;      g.setColor(new Color(60, 60, 60)); // Professional dark gray&#10;      g.drawString(tempString, leftSpace + 5, FConfig.SCREEN_FONT_SIZE + 10);&#10;&#10;    } else if (currentChart.getChartType() == ChartType.OBV) {&#10;      g.setColor(new Color(60, 60, 60)); // Professional dark gray&#10;      g.drawString(currentChart.getChartData().getCode() + &quot; &quot; + ChartLabelText.getLabel(19, language),&#10;        leftSpace + 10, FConfig.SCREEN_FONT_SIZE + 10);&#10;    } else if (currentChart.getChartType() == ChartType.STC) {&#10;      // Draw chart name in dark gray&#10;      String chartName = ChartLabelText.getLabel(18, language);&#10;      g.setColor(new Color(60, 60, 60)); // Professional dark gray&#10;      g.drawString(chartName, leftSpace + 10, FConfig.SCREEN_FONT_SIZE + 10);&#10;&#10;      // Calculate position for %K label based on chart name width&#10;      int chartNameWidth = g.getFontMetrics().stringWidth(chartName);&#10;      int xPosK = leftSpace + 10 + chartNameWidth + 20; // 20px spacing&#10;&#10;      // Draw %K label&#10;      String tempStringK = &quot;%K(&quot; + currentChart.getChartData().getfTAconfig().STCKPeriod + &quot;)&quot;;&#10;      g.setColor(FConfig.STCColorK);&#10;      g.drawString(tempStringK, xPosK, FConfig.SCREEN_FONT_SIZE + 10);&#10;&#10;      // Calculate position for %D label based on %K label width&#10;      int kLabelWidth = g.getFontMetrics().stringWidth(tempStringK);&#10;      int xPosD = xPosK + kLabelWidth + 20; // 20px spacing&#10;&#10;      // Draw %D label&#10;      String tempStringD = &quot;%D(&quot; + currentChart.getChartData().getfTAconfig().STCDPeriod + &quot;)&quot;;&#10;      g.setColor(FConfig.STCColorD);&#10;      g.drawString(tempStringD, xPosD, FConfig.SCREEN_FONT_SIZE + 10);&#10;    } else if (currentChart.getChartType() == ChartType.WILLIAM_R) {&#10;      String tempString = currentChart.getChartData().getCode() + &quot; &quot; + ChartLabelText.getLabel(21, language);&#10;      tempString = tempString + &quot;(&quot; + currentChart.getChartData().getfTAconfig().WilliamPeriod + &quot;)&quot;;&#10;      g.setColor(new Color(60, 60, 60)); // Professional dark gray&#10;      g.drawString(tempString, leftSpace + 10, FConfig.SCREEN_FONT_SIZE + 10);&#10;    }&#10;  }&#10;&#10;  // plot the Left YAxis&#10;  private synchronized void plotYAxis(ChartItem currentChart, boolean isLabel) {&#10;    if (currentChart == null) {&#10;      return;&#10;    }&#10;    if (currentChart.getChartBound() == null) {&#10;      return;&#10;    }&#10;&#10;    // Use a more subtle grid color for professional appearance&#10;    if (gridColor == null) {&#10;      gridColor = new Color(230, 230, 235); // Softer grid lines&#10;    }&#10;&#10;    // calculate the actual bound in the Yaxis.&#10;    double Max = currentChart.getUpperBound();&#10;    double Min = currentChart.getLowerBound();&#10;&#10;    float div = (float) (Max - Min) / 5f;&#10;    float ddiv = div;&#10;&#10;    if (div &lt; 1 &amp;&amp; div &gt;= 0.1) {&#10;      int tempd = Math.round((div * 10));&#10;      ddiv = (tempd) / 10f;&#10;    } else if (div &lt; 0.1 &amp;&amp; div &gt;= 0.01) {&#10;      int tempd = Math.round(div * 100);&#10;      ddiv = (tempd) / 100f;&#10;    } else if (div &lt; 10 &amp;&amp; div &gt;= 1) {&#10;      int tempd = (int) (div);&#10;      ddiv = tempd;&#10;    } else if (div &lt; 100 &amp;&amp; div &gt;= 10) {&#10;      int tempd = (int) (div);&#10;      ddiv = tempd;&#10;    } else if (div &lt; 1000 &amp;&amp; div &gt;= 100) {&#10;      int tempd = (int) (div / 10);&#10;      tempd = tempd * 10;&#10;      ddiv = tempd;&#10;    } else if (div &gt;= 1000) {&#10;      int tempd = (int) (div / 1000);&#10;      tempd = tempd * 1000;&#10;      ddiv = tempd;&#10;    }&#10;&#10;    int tempi = (int) ((float) Min / ddiv);&#10;    float fmin = (tempi * ddiv);&#10;    double sg;&#10;    sg = (tempi) * ddiv; // the first grid line value;&#10;&#10;    // if ((Max/ddiv)&gt;100) return;&#10;    // it is used to fix the bug that ddiv == 0, it occur where the server&#10;    // data error.&#10;    if ((ddiv &lt; 0.0001f) || ((sg + 20 * ddiv) &lt; Max)) {&#10;      return;&#10;    }&#10;&#10;    // if it is TA chart then 0 to 100 axis&#10;    if (currentChart.getChartType() == ChartType.RSI || currentChart.getChartType() == ChartType.STC&#10;      || currentChart.getChartType() == ChartType.WILLIAM_R) {&#10;      sg = 0.0f;&#10;      ddiv = 20f;&#10;    }&#10;&#10;    Graphics g = getAllScreenImage().getGraphics();&#10;    Graphics gg = getScreenImage().getGraphics();&#10;&#10;    // if the screen is small, reduce the font size&#10;    if (this.getSize().height &lt; 150) {&#10;      g.setFont(new Font(&quot;&quot;, 0, 10));&#10;      gg.setFont(new Font(&quot;&quot;, 0, 10));&#10;    } else {&#10;      g.setFont(FConfig.DEFAULT_FONT);&#10;      gg.setFont(FConfig.DEFAULT_FONT);&#10;&#10;    }&#10;&#10;    if (currentChart.getAxisBar() == AxisType.LEFTAXIS) {&#10;      for (; sg &lt;= Max; sg = sg + ddiv) {&#10;        int ypos = getScreenYPosition(sg, Max, Min);&#10;        if (sg &lt; Min || sg &gt; Max) {&#10;          continue;&#10;        }&#10;        if (!isLabel) {&#10;          // Draw solid grid lines with subtle color for professional look&#10;          gg.setColor(gridColor);&#10;          if (gg instanceof Graphics2D) {&#10;            Graphics2D g2d = (Graphics2D) gg;&#10;            g2d.setStroke(new BasicStroke(0.5f)); // Thin, subtle grid lines&#10;            g2d.drawLine(leftSpace, ypos, leftSpace + getXAxisWidth(), ypos);&#10;            g2d.setStroke(new BasicStroke(1.0f)); // Reset stroke&#10;          } else {&#10;            drawDotLine(gg, leftSpace, ypos, leftSpace + getXAxisWidth(), ypos);&#10;          }&#10;          continue;&#10;        }&#10;&#10;        // Draw axis tick marks&#10;        g.setColor(new Color(80, 80, 80)); // Professional dark gray&#10;        g.drawLine(leftSpace, ypos, leftSpace - 3, ypos);&#10;        g.setColor(currentChart.getFirstColor());&#10;        String ss;&#10;        if (currentChart.getChartType() == ChartType.VOLUME) {&#10;          ss = FormatUtil.formatInteger(sg);&#10;        } else if (currentChart.getChartType() == ChartType.PERCENTAGE) {&#10;          ss = FormatUtil.formatInteger(sg) + &quot;%&quot;;&#10;        } else if (currentChart.getChartType() == ChartType.RSI || currentChart.getChartType() == ChartType.STC&#10;          || currentChart.getChartType() == ChartType.WILLIAM_R) {&#10;          ss = String.valueOf((int) (sg + 0.5));&#10;        } else if (currentChart.getChartType() == ChartType.OBV) {&#10;          ss = FormatUtil.formatOBV(sg);&#10;        } else {&#10;          if (sg &gt; 1000) {&#10;            // ss = String.valueOf((int)(sg+0.5));&#10;            ss = FormatUtil.formatInteger(sg + 0.5);&#10;          } else {&#10;            ss = FormatUtil.format2DecimalPlace(sg);&#10;          }&#10;        }&#10;        // Use professional dark gray for axis labels&#10;        g.setColor(new Color(60, 60, 60));&#10;        int strLength = g.getFontMetrics().charsWidth(ss.toCharArray(), 0, ss.length());&#10;&#10;        g.drawString(ss, leftSpace - strLength - 10, ypos + 3);&#10;      }&#10;    } else if (currentChart.getAxisBar() == AxisType.RIGHTAXIS) {&#10;      for (; sg &lt; Max; sg = sg + ddiv) {&#10;        if (sg &lt; Min || sg &gt; Max) {&#10;          continue;&#10;        }&#10;        int ypos = getScreenYPosition(sg, Max, Min);&#10;        g.setColor(new Color(60, 60, 60)); // Professional dark gray&#10;        g.drawLine(leftSpace + getXAxisWidth(), ypos, leftSpace + getXAxisWidth() + 3, ypos);&#10;        String ss = FormatUtil.format2DecimalPlace(sg);&#10;        g.setColor(currentChart.getFirstColor());&#10;        g.drawString(ss, leftSpace + getXAxisWidth() + 6, ypos + 3);&#10;      }&#10;    }&#10;  }&#10;&#10;  // switch to different type of chart to plot&#10;  private void plotChart(ChartItem currentChart) {&#10;    switch (currentChart.getChartType()) {&#10;      case LINE:&#10;        plotLineChart(currentChart);&#10;        break;&#10;      case BAR:&#10;        plotBarChart(currentChart);&#10;        break;&#10;&#10;      case CANDLE:&#10;        plotCandleChart(currentChart);&#10;        break;&#10;&#10;      case VOLUME:&#10;        plotVolumeChart(currentChart);&#10;        break;&#10;&#10;      case PERCENTAGE:&#10;        plotPercentageChart(currentChart);&#10;        break;&#10;&#10;      case SIMPLE_MOVING_AVERAGE:&#10;        plotMovingAverage(currentChart);&#10;        break;&#10;&#10;      case WEIGHTED_MOVING_AVERAGE:&#10;        plotMovingAverage(currentChart);&#10;        break;&#10;&#10;      case EXPONENTIAL_MOVING_AVERAGE:&#10;        plotMovingAverage(currentChart);&#10;        break;&#10;&#10;      case BOLLINGERBAND:&#10;        plotBollingerBand(currentChart);&#10;        break;&#10;&#10;      case RSI:&#10;        plotRSI(currentChart);&#10;        break;&#10;&#10;      case MACD:&#10;        plotMACD(currentChart);&#10;        break;&#10;&#10;      case WILLIAM_R:&#10;        plotWILLIAM_R(currentChart);&#10;        break;&#10;&#10;      case OBV:&#10;        plotOBV(currentChart);&#10;        break;&#10;&#10;      case STC:&#10;        plotSTC(currentChart);&#10;        break;&#10;&#10;    }&#10;&#10;  }&#10;&#10;  // clear the Screen&#10;  private synchronized boolean clearScreen() {&#10;    Graphics screenG = getScreenImage().getGraphics();&#10;&#10;    // Enable anti-aliasing for smooth rendering&#10;    if (screenG instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) screenG;&#10;      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;      g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);&#10;    }&#10;&#10;    // Use a subtle gradient background for professional look&#10;    if (screenG instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) screenG;&#10;      GradientPaint gradient = new GradientPaint(&#10;        0, 0, new Color(255, 255, 255),&#10;        0, getSize().height, new Color(248, 248, 250)&#10;      );&#10;      g2d.setPaint(gradient);&#10;      g2d.fillRect(0, 0, getSize().width, getSize().height);&#10;    } else {&#10;      screenG.setColor(FConfig.ChatBackground);&#10;      screenG.fillRect(0, 0, getSize().width, getSize().height);&#10;    }&#10;    return true;&#10;  }&#10;&#10;  // remove all charts.&#10;  public void removeAllCharts() {&#10;    this.chartObjects.removeAllElements();&#10;    updateBaseScreen();&#10;  }&#10;&#10;  // plot the Axis&#10;  private boolean plotAxis(boolean isLabel) {&#10;    Graphics screenG = getAllScreenImage().getGraphics();&#10;&#10;    // Enable anti-aliasing for smooth lines&#10;    if (screenG instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) screenG;&#10;      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;      g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);&#10;    }&#10;&#10;    // Draw main axes with a professional dark gray color&#10;    screenG.setColor(new Color(80, 80, 80));&#10;    if (screenG instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) screenG;&#10;      g2d.setStroke(new BasicStroke(1.5f));&#10;    }&#10;&#10;    screenG.drawLine(leftSpace, topSpace, leftSpace, topSpace + getYAxisWidth());&#10;    screenG.drawLine(leftSpace, topSpace + getYAxisWidth(), leftSpace + getXAxisWidth(),&#10;      topSpace + getYAxisWidth());&#10;&#10;    // Reset to normal stroke&#10;    if (screenG instanceof Graphics2D) {&#10;      Graphics2D g2d = (Graphics2D) screenG;&#10;      g2d.setStroke(new BasicStroke(1.0f));&#10;    }&#10;&#10;    screenG.setColor(FConfig.ScreenBackground);&#10;&#10;    try {&#10;      for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;        ChartItem currentChart = (ChartItem) chartObjects.elementAt(i);&#10;        if (currentChart.isVisible()) {&#10;          plotXAxis(currentChart, isLabel);&#10;          plotYAxis(currentChart, isLabel);&#10;          drawLabel(currentChart);&#10;        }&#10;      }&#10;    } catch (Exception e) {&#10;      log.warning(&quot;Error plotting chart axes: &quot; + e.getMessage());&#10;    }&#10;    return true;&#10;  }&#10;&#10;  // get the Maximum Number of point that the screen can display.&#10;  private int getMaxNumberOfDisplayPoint() {&#10;    // because minimum pixels per point.&#10;    return (getXAxisWidth() - 2) / minResolution - 2;&#10;  }&#10;&#10;  // get the Maximum Number of display point that the screen can display in&#10;  // the current resoluation&#10;  private int getMaxNumberOfDisplayPointInCurrentResolution() {&#10;    return (getXAxisWidth() - 2) / resolution;&#10;  }&#10;&#10;  // retrieve the (central) point position in the screen&#10;  public int getScreenXPositionFromPoint(int pointIndex) {&#10;    return leftSpace + 1 + (pointIndex - startDisplayIndex) * resolution + resolution / 2;&#10;  }&#10;&#10;  // retrieve index from screenPos (Xaxis)&#10;  public int getPointIndexFromScreen(int screenPos) {&#10;    return startDisplayIndex + (screenPos - leftSpace - 1) / resolution;&#10;  }&#10;&#10;  // retrieve the Abract Y position given the value and the range.....&#10;  public int getScreenYPosition(double value, double MaxValue, double MinValue) {&#10;    MinValue = MinValue - 0.0001f;&#10;    double dpos = (double) getYAxisWidth() - ((value - MinValue) / (MaxValue - MinValue) * getYAxisWidth())&#10;      + topSpace;&#10;    int pos = (int) Math.round(dpos);&#10;    return pos;&#10;  }&#10;&#10;  public double getYValueFromScreen(int y, double MaxValue, double MinValue) {&#10;    double dValue = ((double) (getYAxisWidth() - y + topSpace) / getYAxisWidth()) * (MaxValue - MinValue)&#10;      + MinValue;&#10;    return dValue;&#10;  }&#10;&#10;  public void setSpace(int ileftSpace, int irightSpace, int itopSpace, int ibottomSpace) {&#10;    leftSpace = ileftSpace;&#10;    rightSpace = irightSpace;&#10;    topSpace = itopSpace;&#10;    bottomSpace = ibottomSpace;&#10;  }&#10;&#10;  public void mouseDragged(MouseEvent e) {&#10;    if (actionCommand.getActionType() == ActionType.WATCH&#10;      || actionCommand.getActionType() == ActionType.MOVE_CHART) {&#10;      if (!isWithinChartRegion(e.getX(), e.getY())) {&#10;        actionCommand.setProcessing(false);&#10;        repaint();&#10;        return;&#10;      }&#10;    }&#10;    switch (actionCommand.getActionType()) {&#10;      case ZOOM_IN:&#10;      case INSERT_LINE:&#10;      case GOLDEN_PARTITION:&#10;        actionCommand.getCurrentMousePoint().x = e.getPoint().x;&#10;        actionCommand.getCurrentMousePoint().y = e.getPoint().y;&#10;        repaint();&#10;        break;&#10;&#10;      case MOVE_CHART:&#10;        if (e.getPoint().x &gt; actionCommand.getCurrentMousePoint().x + 1) {&#10;          this.moveLeft();&#10;          actionCommand.getCurrentMousePoint().x = e.getPoint().x;&#10;          actionCommand.getCurrentMousePoint().y = e.getPoint().y;&#10;        } else if (e.getPoint().x &lt; actionCommand.getCurrentMousePoint().x - 1) {&#10;          this.moveRight();&#10;          actionCommand.getCurrentMousePoint().x = e.getPoint().x;&#10;          actionCommand.getCurrentMousePoint().y = e.getPoint().y;&#10;        }&#10;        break;&#10;    }&#10;&#10;  }&#10;&#10;  public void mouseMoved(MouseEvent e) {&#10;    if (!isWithinChartRegion(e.getX(), e.getY())) {&#10;      actionCommand.setProcessing(false);&#10;&#10;    }&#10;&#10;    actionCommand.getCurrentMousePoint().x = e.getX();&#10;    actionCommand.getCurrentMousePoint().y = e.getY();&#10;    switch (actionCommand.getActionType()) {&#10;      case INSERT_PARALLEL_LINE:&#10;        if (actionCommand.getLineRecords().size() == 0) {&#10;          actionCommand.setProcessing(false);&#10;        } else {&#10;          actionCommand.setProcessing(true);&#10;          repaint();&#10;        }&#10;        break;&#10;&#10;      case WATCH:&#10;        actionCommand.setProcessing(true);&#10;        repaint();&#10;        break;&#10;&#10;      case NONE_ACTION:&#10;      default:&#10;        actionCommand.setProcessing(false);&#10;        break;&#10;    }&#10;&#10;  }&#10;&#10;  public void mousePressed(MouseEvent e) {&#10;&#10;    if (!isWithinChartRegion(e.getX(), e.getY())) {&#10;      actionCommand.setProcessing(false);&#10;      return;&#10;    }&#10;&#10;    switch (actionCommand.getActionType()) {&#10;      case ZOOM_IN:&#10;      case INSERT_LINE:&#10;      case GOLDEN_PARTITION:&#10;        actionCommand.setProcessing(true);&#10;        actionCommand.getStartMousePoint().x = e.getPoint().x;&#10;        actionCommand.getStartMousePoint().y = e.getPoint().y;&#10;        break;&#10;&#10;      case MOVE_CHART:&#10;        Toolkit toolkit = Toolkit.getDefaultToolkit();&#10;        Cursor c = toolkit.createCustomCursor(moveCursorImage, new Point(16, 16), &quot;img&quot;);&#10;        setCursor(c);&#10;&#10;        actionCommand.setProcessing(true);&#10;        actionCommand.getStartMousePoint().x = e.getPoint().x;&#10;        actionCommand.getStartMousePoint().y = e.getPoint().y;&#10;        actionCommand.getCurrentMousePoint().x = e.getPoint().x;&#10;        actionCommand.getCurrentMousePoint().y = e.getPoint().y;&#10;        break;&#10;&#10;    }&#10;&#10;  }&#10;&#10;  public void mouseReleased(MouseEvent e) {&#10;    if (actionCommand.getActionType() == ActionType.WATCH&#10;      || actionCommand.getActionType() == ActionType.MOVE_CHART) {&#10;      if (!isWithinChartRegion(e.getX(), e.getY())) {&#10;        actionCommand.setProcessing(false);&#10;        return;&#10;      }&#10;    }&#10;&#10;    setCursor(null);&#10;&#10;    FLine fline;&#10;    switch (actionCommand.getActionType()) {&#10;&#10;      ///// Handle Zoom in action&#10;      ///// ///////////////////////////////////////////////////////////////////&#10;      case ZOOM_IN:&#10;        // actionCommand.mouseFlag = false;&#10;        actionCommand.setProcessing(false);&#10;        actionCommand.getReleaseMousePoint().x = e.getPoint().x;&#10;        actionCommand.getReleaseMousePoint().y = e.getPoint().y;&#10;        int index1 = getPointIndexFromScreen(actionCommand.getReleaseMousePoint().x);&#10;        int index2 = getPointIndexFromScreen(actionCommand.getStartMousePoint().x);&#10;&#10;        if (Math.abs(index1 - index2) &gt; 5) {&#10;          int startIndex = Math.min(index1, index2);&#10;          int endIndex = Math.max(index1, index2);&#10;          if (endIndex &gt; endDisplayIndex) {&#10;            endIndex = endDisplayIndex;&#10;          }&#10;          if (startIndex &lt; startDisplayIndex) {&#10;            startIndex = startDisplayIndex;&#10;          }&#10;          // record the previous position;&#10;          actionCommand.getZoomRecords().addElement(new Point(startDisplayIndex, endDisplayIndex));&#10;          // change the zoom&#10;          zoom(startIndex, endIndex);&#10;        } else {&#10;          repaint();&#10;        }&#10;        break;&#10;&#10;      ///// Handle insert line action&#10;      ///// //////////////////////////////////////////////////////////////////&#10;      case INSERT_LINE:&#10;        actionCommand.setProcessing(false);&#10;        actionCommand.getReleaseMousePoint().x = e.getPoint().x;&#10;        actionCommand.getReleaseMousePoint().y = e.getPoint().y;&#10;        if (FLine.isFixedLine()) {&#10;          fline = new FLine(actionCommand.getStartMousePoint().x, actionCommand.getStartMousePoint().y,&#10;            actionCommand.getReleaseMousePoint().x, actionCommand.getReleaseMousePoint().y);&#10;          actionCommand.getLineRecords().addElement(fline);&#10;        } else {&#10;          int x1 = getPointIndexFromScreen(actionCommand.getStartMousePoint().x);&#10;          int x2 = getPointIndexFromScreen(actionCommand.getReleaseMousePoint().x);&#10;          float y1, y2;&#10;          ChartItem cchart = this.getLeftChart();&#10;          if (cchart != null) {&#10;            float Min = (float) cchart.getLowerBound();&#10;            float Max = (float) cchart.getUpperBound();&#10;            y1 = (float) getYValueFromScreen(actionCommand.getStartMousePoint().y, Max, Min);&#10;            y2 = (float) getYValueFromScreen(actionCommand.getReleaseMousePoint().y, Max, Min);&#10;            fline = new FLine(x1, y1, x2, y2);&#10;            fline.getPoint1().x = actionCommand.getStartMousePoint().x;&#10;            fline.getPoint1().y = actionCommand.getStartMousePoint().y;&#10;            fline.getPoint2().x = actionCommand.getReleaseMousePoint().x;&#10;            fline.getPoint2().y = actionCommand.getReleaseMousePoint().y;&#10;            actionCommand.getLineRecords().addElement(fline);&#10;          }&#10;        }&#10;        repaint();&#10;        break;&#10;&#10;      case GOLDEN_PARTITION:&#10;        actionCommand.setProcessing(false);&#10;        actionCommand.getReleaseMousePoint().x = e.getPoint().x;&#10;        actionCommand.getReleaseMousePoint().y = e.getPoint().y;&#10;&#10;        if (FLine.isFixedLine()) {&#10;          fline = new FLine(actionCommand.getStartMousePoint().x, actionCommand.getStartMousePoint().y,&#10;            actionCommand.getReleaseMousePoint().x, actionCommand.getReleaseMousePoint().y);&#10;          actionCommand.setGoldenPartitionLine(fline);&#10;        } else {&#10;          int x1 = getPointIndexFromScreen(actionCommand.getStartMousePoint().x);&#10;          int x2 = getPointIndexFromScreen(actionCommand.getReleaseMousePoint().x);&#10;          float y1, y2;&#10;          ChartItem cchart = this.getLeftChart();&#10;          if (cchart != null) {&#10;            float Min = (float) cchart.getLowerBound();&#10;            float Max = (float) cchart.getUpperBound();&#10;            y1 = (float) getYValueFromScreen(actionCommand.getStartMousePoint().y, Max, Min);&#10;            y2 = (float) getYValueFromScreen(actionCommand.getReleaseMousePoint().y, Max, Min);&#10;            fline = new FLine(x1, y1, x2, y2);&#10;            fline.getPoint1().x = actionCommand.getStartMousePoint().x;&#10;            fline.getPoint1().y = actionCommand.getStartMousePoint().y;&#10;            fline.getPoint2().x = actionCommand.getReleaseMousePoint().x;&#10;            fline.getPoint2().y = actionCommand.getReleaseMousePoint().y;&#10;            actionCommand.setGoldenPartitionLine(fline);&#10;          }&#10;        }&#10;&#10;        if (Math.abs(actionCommand.getStartMousePoint().y - actionCommand.getReleaseMousePoint().y) &lt; 5) {&#10;          actionCommand.setGoldenPartitionLine(null);&#10;        }&#10;&#10;        repaint();&#10;        break;&#10;&#10;      // handle move chart action -- disable it when release the button&#10;      // .//////////////////////////////&#10;      case MOVE_CHART:&#10;        actionCommand.setProcessing(false);&#10;        break;&#10;&#10;    }&#10;  }&#10;&#10;  public void mouseEntered(MouseEvent e) {&#10;    repaint();&#10;  }&#10;&#10;  public void mouseExited(MouseEvent e) {&#10;    switch (actionCommand.getActionType()) {&#10;      // still perform the action.&#10;      case GOLDEN_PARTITION:&#10;      case INSERT_PARALLEL_LINE:&#10;      case INSERT_LINE:&#10;      case ZOOM_IN:&#10;        break;&#10;&#10;      // cancel the action.&#10;      default:&#10;        actionCommand.setProcessing(false);&#10;        repaint();&#10;        this.screenActionListener.OnWatch(this, -999);&#10;        break;&#10;    }&#10;  }&#10;&#10;  protected boolean isWithinCloseButton(int x, int y) {&#10;&#10;    return x &gt;= (getWidth() - 17) &amp;&amp; x &lt;= getWidth() &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 15;&#10;&#10;  }&#10;&#10;  public void mouseClicked(MouseEvent e) {&#10;&#10;    if (isWithinCloseButton(e.getX(), e.getY())) {&#10;      this.setVisible(false);&#10;      return;&#10;    }&#10;&#10;    if (!isWithinChartRegion(e.getX(), e.getY())) {&#10;      actionCommand.setProcessing(false);&#10;      return;&#10;    }&#10;    switch (actionCommand.getActionType()) {&#10;      case ZOOM_IN:&#10;        String mparamString = e.paramString();&#10;        // if right click mouse&#10;        if (mparamString.indexOf(&quot;mods=4&quot;) &gt; 0) {&#10;          this.undoZoom();&#10;        }&#10;        break;&#10;&#10;      // when mouse click insert a parallel line into&#10;      // action.lineRecords.///////////////////////////////////&#10;      case INSERT_PARALLEL_LINE:&#10;        if (!isWithinChartRegion(e.getX(), e.getY())) {&#10;          return;&#10;        }&#10;&#10;        FLine fline = (FLine) actionCommand.getLineRecords().lastElement();&#10;        Point rpoint = new Point(0, 0);&#10;        if (fline.getPoint1().x &lt; fline.getPoint2().x) {&#10;          rpoint.x = fline.getPoint1().x;&#10;          rpoint.y = fline.getPoint1().y;&#10;        } else {&#10;          rpoint.x = fline.getPoint2().x;&#10;          rpoint.y = fline.getPoint2().y;&#10;        }&#10;        int dx = +actionCommand.getCurrentMousePoint().x - rpoint.x;&#10;        int dy = +actionCommand.getCurrentMousePoint().y - rpoint.y;&#10;        if (FLine.isFixedLine()) {&#10;          FLine newFline = new FLine(fline.getPoint1().x + dx, fline.getPoint1().y + dy, fline.getPoint2().x + dx,&#10;            fline.getPoint2().y + dy);&#10;          actionCommand.getLineRecords().addElement(newFline);&#10;        } else {&#10;&#10;          int x1 = getPointIndexFromScreen(fline.getPoint1().x + dx);&#10;          int x2 = getPointIndexFromScreen(fline.getPoint2().x + dx);&#10;          float y1, y2;&#10;          ChartItem cchart = this.getLeftChart();&#10;          if (cchart != null) {&#10;            float Min = (float) cchart.getLowerBound();&#10;            float Max = (float) cchart.getUpperBound();&#10;            y1 = (float) getYValueFromScreen(fline.getPoint1().y + dy, Max, Min);&#10;            y2 = (float) getYValueFromScreen(fline.getPoint2().y + dy, Max, Min);&#10;            FLine newfline = new FLine(x1, y1, x2, y2);&#10;            newfline.getPoint1().x = fline.getPoint1().x + dx;&#10;            newfline.getPoint1().y = fline.getPoint1().y + dy;&#10;            newfline.getPoint2().x = fline.getPoint2().x + dx;&#10;            newfline.getPoint2().y = fline.getPoint2().y + dy;&#10;            actionCommand.getLineRecords().addElement(newfline);&#10;          }&#10;&#10;        }&#10;        repaint();&#10;        break;&#10;      case EDIT_TEXT:&#10;        ChartItem cchart = this.getLeftChart();&#10;        if (cchart != null) {&#10;          float Min = (float) cchart.getLowerBound();&#10;          float Max = (float) cchart.getUpperBound();&#10;          int x1 = getPointIndexFromScreen(e.getX());&#10;          float y1 = (float) getYValueFromScreen(e.getY(), Max, Min);&#10;          JDialog jd = new JDialog();&#10;          String s = JOptionPane.showInputDialog(this, &quot;&quot;, &quot;&quot;);&#10;          if (s != null &amp;&amp; !s.trim().equals(&quot;&quot;)) {&#10;            FText textRecord = new FText(s, x1, y1);&#10;            actionCommand.getTextRecords().addElement(textRecord);&#10;          }&#10;        }&#10;        repaint();&#10;        break;&#10;    }&#10;  }&#10;&#10;  // End: response of mouse action&#10;  // .............................................&#10;  // move chart to left&#10;  public void moveLeft() {&#10;    if ((startDisplayIndex - 1) &gt;= 0) {&#10;      int startIndex = startDisplayIndex - 1;&#10;      int endIndex = endDisplayIndex - 1;&#10;      zoom(startIndex, endIndex);&#10;      this.updateBaseScreen();&#10;      this.repaint();&#10;    }&#10;  }&#10;&#10;  // move chart to right&#10;  public void moveRight() {&#10;    if ((endDisplayIndex + 1) &lt; maxNumberOfChartPoint) {&#10;      int startIndex = startDisplayIndex + 1;&#10;      int endIndex = endDisplayIndex + 1;&#10;      zoom(startIndex, endIndex);&#10;      this.updateBaseScreen();&#10;      this.repaint();&#10;    }&#10;  }&#10;&#10;  public ChartItem getLeftChart() {&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;      if (cchart.getAxisBar() == AxisType.LEFTAXIS) {&#10;        return cchart;&#10;      }&#10;    }&#10;    return null;&#10;  }&#10;&#10;  public synchronized ChartItem getRightChart() {&#10;    for (int i = 0; i &lt; chartObjects.size(); i++) {&#10;      ChartItem cchart = (ChartItem) chartObjects.elementAt(i);&#10;      if (cchart.getAxisBar() == AxisType.RIGHTAXIS) {&#10;        return cchart;&#10;      }&#10;    }&#10;    return null;&#10;  }&#10;&#10;  public void undoInsertLine() {&#10;    if (actionCommand.getLineRecords().size() &gt; 0) {&#10;      FLine fline = (FLine) actionCommand.getLineRecords().lastElement();&#10;      actionCommand.getLineRecords().removeElement(fline);&#10;    }&#10;    repaint();&#10;&#10;  }&#10;&#10;  // Undo Zoom&#10;  public Point undoZoom() {&#10;    int endIndex = maxNumberOfChartPoint - 1;&#10;    int startIndex = Math.max(0, endIndex - getMaxNumberOfDisplayPoint());&#10;    Point ozoom = new Point(startIndex, endIndex);&#10;    if (actionCommand.getZoomRecords().size() &gt; 0) {&#10;      ozoom = (Point) actionCommand.getZoomRecords().lastElement();&#10;      actionCommand.getZoomRecords().removeElement(ozoom);&#10;      zoom(ozoom.x, ozoom.y);&#10;      return ozoom;&#10;    } else if (actionCommand.getZoomRecords().size() == 0) {&#10;      zoom(ozoom.x, ozoom.y);&#10;      return ozoom;&#10;    }&#10;    return ozoom;&#10;  }&#10;&#10;  public synchronized void addScreenActionListen(ScreenActionListener ss) {&#10;    screenActionListener = ss;&#10;  }&#10;&#10;  public synchronized void flipLoading() {&#10;    repaint();&#10;  }&#10;&#10;  public synchronized Image getScreenImage() {&#10;    return screenImage;&#10;  }&#10;&#10;  public void setScreenImage(Image screenImage) {&#10;    this.screenImage = screenImage;&#10;  }&#10;&#10;  public Image getAllScreenImage() {&#10;    return allscreenImage;&#10;  }&#10;&#10;  public void setAllScreenImage(Image allscreenImage) {&#10;    this.allscreenImage = allscreenImage;&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
  <component name="CopyrightManager" default="" />
  <component name="DependencyValidationManager">
    <option name="SKIP_IMPORT_STATEMENTS" value="false" />
  </component>
  <component name="EditMigrationStateService">
    <option name="migrationStatus" value="COMPLETED" />
  </component>
  <component name="GradleMigrationSettings" migrationVersion="1" />
  <component name="GradleSettings">
    <option name="linkedExternalProjectsSettings">
      <GradleProjectSettings>
        <option name="distributionType" value="LOCAL" />
        <option name="externalProjectPath" value="$PROJECT_DIR$" />
        <option name="gradleJvm" value="22" />
        <option name="modules">
          <set>
            <option value="$PROJECT_DIR$" />
          </set>
        </option>
      </GradleProjectSettings>
    </option>
  </component>
  <component name="GradleUISettings">
    <setting name="root" />
  </component>
  <component name="GradleUISettings2">
    <setting name="root" />
  </component>
  <component name="IdProvider" IDEtalkID="11DA1DB66DD62DDA1ED602B7079FE97C" />
  <component name="InspectionProjectProfileManager">
    <profile version="1.0">
      <option name="myName" value="Project Default" />
    </profile>
    <version value="1.0" />
  </component>
  <component name="JavadocGenerationManager">
    <option name="OUTPUT_DIRECTORY" />
    <option name="OPTION_SCOPE" value="protected" />
    <option name="OPTION_HIERARCHY" value="true" />
    <option name="OPTION_NAVIGATOR" value="true" />
    <option name="OPTION_INDEX" value="true" />
    <option name="OPTION_SEPARATE_INDEX" value="true" />
    <option name="OPTION_DOCUMENT_TAG_USE" value="false" />
    <option name="OPTION_DOCUMENT_TAG_AUTHOR" value="false" />
    <option name="OPTION_DOCUMENT_TAG_VERSION" value="false" />
    <option name="OPTION_DOCUMENT_TAG_DEPRECATED" value="true" />
    <option name="OPTION_DEPRECATED_LIST" value="true" />
    <option name="OTHER_OPTIONS" value="" />
    <option name="HEAP_SIZE" />
    <option name="LOCALE" />
    <option name="OPEN_IN_BROWSER" value="true" />
  </component>
  <component name="Palette2">
    <group name="Swing">
      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />
      </item>
      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />
      </item>
      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">
        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />
      </item>
      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">
        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />
      </item>
      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">
        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />
        <initial-values>
          <property name="text" value="Button" />
        </initial-values>
      </item>
      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">
        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
        <initial-values>
          <property name="text" value="RadioButton" />
        </initial-values>
      </item>
      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">
        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
        <initial-values>
          <property name="text" value="CheckBox" />
        </initial-values>
      </item>
      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">
        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />
        <initial-values>
          <property name="text" value="Label" />
        </initial-values>
      </item>
      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">
        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
          <preferred-size width="150" height="-1" />
        </default-constraints>
      </item>
      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">
        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
          <preferred-size width="150" height="-1" />
        </default-constraints>
      </item>
      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">
        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
          <preferred-size width="150" height="-1" />
        </default-constraints>
      </item>
      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">
        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
          <preferred-size width="150" height="50" />
        </default-constraints>
      </item>
      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
          <preferred-size width="150" height="50" />
        </default-constraints>
      </item>
      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
          <preferred-size width="150" height="50" />
        </default-constraints>
      </item>
      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">
        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />
      </item>
      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">
        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
          <preferred-size width="150" height="50" />
        </default-constraints>
      </item>
      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">
        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">
          <preferred-size width="150" height="50" />
        </default-constraints>
      </item>
      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">
        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
          <preferred-size width="150" height="50" />
        </default-constraints>
      </item>
      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">
        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
          <preferred-size width="200" height="200" />
        </default-constraints>
      </item>
      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">
        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
          <preferred-size width="200" height="200" />
        </default-constraints>
      </item>
      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">
        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
      </item>
      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">
        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
      </item>
      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">
        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />
      </item>
      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />
      </item>
      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">
        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">
          <preferred-size width="-1" height="20" />
        </default-constraints>
      </item>
      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">
        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />
      </item>
      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />
      </item>
    </group>
  </component>
  <component name="ProjectCodeStyleConfiguration">
    <option name="PREFERRED_PROJECT_CODE_STYLE" value="Default" />
  </component>
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/ic.iml" filepath="$PROJECT_DIR$/ic.iml" />
      <module fileurl="file://$PROJECT_DIR$/ic.main.iml" filepath="$PROJECT_DIR$/ic.main.iml" />
      <module fileurl="file://$PROJECT_DIR$/ic.test.iml" filepath="$PROJECT_DIR$/ic.test.iml" />
      <module fileurl="file://$PROJECT_DIR$/ic_main.iml" filepath="$PROJECT_DIR$/ic_main.iml" group="ic" />
      <module fileurl="file://$PROJECT_DIR$/ic_test.iml" filepath="$PROJECT_DIR$/ic_test.iml" group="ic" />
    </modules>
  </component>
  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" project-jdk-name="jdk-11.0.2" project-jdk-type="JavaSDK">
    <output url="file://$PROJECT_DIR$/out" />
  </component>
  <component name="SvnBranchConfigurationManager">
    <option name="mySupportsUserInfoFilter" value="true" />
  </component>
  <component name="VcsDirectoryMappings">
    <mapping directory="$PROJECT_DIR$" vcs="Git" />
  </component>
  <component name="accountSettings">
    <option name="activeRegion" value="us-east-1" />
    <option name="recentlyUsedRegions">
      <list>
        <option value="us-east-1" />
      </list>
    </option>
  </component>
  <component name="libraryTable">
    <library name="Gradle: junit:junit:4.13.2" type="java-imported" external-system-id="GRADLE">
      <properties groupId="junit" artifactId="junit" version="4.13.2" baseVersion="4.13.2" />
      <CLASSES>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/junit/junit/4.13.2/8ac9e16d933b6fb43bc7f576336b8f4d7eb5ba12/junit-4.13.2.jar!/" />
      </CLASSES>
      <JAVADOC>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/junit/junit/4.13.2/f2f3f384dacd2ade2ddf7aa7e0f4360dfee38672/junit-4.13.2-javadoc.jar!/" />
      </JAVADOC>
      <SOURCES>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/junit/junit/4.13.2/33987872a811fe4d4001ed494b07854822257f42/junit-4.13.2-sources.jar!/" />
      </SOURCES>
    </library>
    <library name="Gradle: net.bytebuddy:byte-buddy-agent:1.12.19" type="java-imported" external-system-id="GRADLE">
      <properties groupId="net.bytebuddy" artifactId="byte-buddy-agent" version="1.12.19" baseVersion="1.12.19" />
      <CLASSES>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/net.bytebuddy/byte-buddy-agent/1.12.19/450917cf3b358b691a824acf4c67aa89c826f67e/byte-buddy-agent-1.12.19.jar!/" />
      </CLASSES>
      <JAVADOC />
      <SOURCES />
    </library>
    <library name="Gradle: net.bytebuddy:byte-buddy:1.12.21" type="java-imported" external-system-id="GRADLE">
      <properties groupId="net.bytebuddy" artifactId="byte-buddy" version="1.12.21" baseVersion="1.12.21" />
      <CLASSES>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/net.bytebuddy/byte-buddy/1.12.21/1a257bbdb9288f2558d3767cc2cc22b499d5091c/byte-buddy-1.12.21.jar!/" />
      </CLASSES>
      <JAVADOC />
      <SOURCES />
    </library>
    <library name="Gradle: org.apache.derby:derbyclient:10.15.2.0" type="java-imported" external-system-id="GRADLE">
      <properties groupId="org.apache.derby" artifactId="derbyclient" version="10.15.2.0" baseVersion="10.15.2.0" />
      <CLASSES>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.apache.derby/derbyclient/10.15.2.0/60ad423e9d7acba99a13b8684927206e94c31e03/derbyclient-10.15.2.0.jar!/" />
      </CLASSES>
      <JAVADOC />
      <SOURCES />
    </library>
    <library name="Gradle: org.apache.derby:derbyshared:10.15.2.0" type="java-imported" external-system-id="GRADLE">
      <properties groupId="org.apache.derby" artifactId="derbyshared" version="10.15.2.0" baseVersion="10.15.2.0" />
      <CLASSES>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.apache.derby/derbyshared/10.15.2.0/ff2dfb3e2a92d593cf111baad242d156947abbc1/derbyshared-10.15.2.0.jar!/" />
      </CLASSES>
      <JAVADOC />
      <SOURCES />
    </library>
    <library name="Gradle: org.assertj:assertj-core:3.24.2" type="java-imported" external-system-id="GRADLE">
      <properties groupId="org.assertj" artifactId="assertj-core" version="3.24.2" baseVersion="3.24.2" />
      <CLASSES>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.24.2/ebbf338e33f893139459ce5df023115971c2786f/assertj-core-3.24.2.jar!/" />
      </CLASSES>
      <JAVADOC />
      <SOURCES />
    </library>
    <library name="Gradle: org.hamcrest:hamcrest-core:1.3" external-system-id="GRADLE">
      <CLASSES>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/42a25dc3219429f0e5d060061f71acb49bf010a0/hamcrest-core-1.3.jar!/" />
      </CLASSES>
      <JAVADOC>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/ad09811315f1d4f5756986575b0ea16b99cd686f/hamcrest-core-1.3-javadoc.jar!/" />
      </JAVADOC>
      <SOURCES>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/1dc37250fbc78e23a65a67fbbaf71d2e9cbc3c0b/hamcrest-core-1.3-sources.jar!/" />
      </SOURCES>
    </library>
    <library name="Gradle: org.json:json:20240303" type="java-imported" external-system-id="GRADLE">
      <properties groupId="org.json" artifactId="json" version="20240303" baseVersion="20240303" />
      <CLASSES>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.json/json/20240303/ebb88e8fb5122b7506d5cf1d69f1ccdb790d22a/json-20240303.jar!/" />
      </CLASSES>
      <JAVADOC />
      <SOURCES />
    </library>
    <library name="Gradle: org.mockito:mockito-core:4.11.0" type="java-imported" external-system-id="GRADLE">
      <properties groupId="org.mockito" artifactId="mockito-core" version="4.11.0" baseVersion="4.11.0" />
      <CLASSES>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.mockito/mockito-core/4.11.0/ce5226440c2ee78915716d4ce3d10aed2dbf26fb/mockito-core-4.11.0.jar!/" />
      </CLASSES>
      <JAVADOC />
      <SOURCES />
    </library>
    <library name="Gradle: org.objenesis:objenesis:3.3" type="java-imported" external-system-id="GRADLE">
      <properties groupId="org.objenesis" artifactId="objenesis" version="3.3" baseVersion="3.3" />
      <CLASSES>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.objenesis/objenesis/3.3/1049c09f1de4331e8193e579448d0916d75b7631/objenesis-3.3.jar!/" />
      </CLASSES>
      <JAVADOC />
      <SOURCES />
    </library>
    <library name="Gradle: org.slf4j:slf4j-api:1.7.36" type="java-imported" external-system-id="GRADLE">
      <properties groupId="org.slf4j" artifactId="slf4j-api" version="1.7.36" baseVersion="1.7.36" />
      <CLASSES>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.slf4j/slf4j-api/1.7.36/6c62681a2f655b49963a5983b8b0950a6120ae14/slf4j-api-1.7.36.jar!/" />
      </CLASSES>
      <JAVADOC />
      <SOURCES />
    </library>
    <library name="Gradle: org.slf4j:slf4j-simple:1.7.36" type="java-imported" external-system-id="GRADLE">
      <properties groupId="org.slf4j" artifactId="slf4j-simple" version="1.7.36" baseVersion="1.7.36" />
      <CLASSES>
        <root url="jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.slf4j/slf4j-simple/1.7.36/a41f9cfe6faafb2eb83a1c7dd2d0dfd844e2a936/slf4j-simple-1.7.36.jar!/" />
      </CLASSES>
      <JAVADOC />
      <SOURCES />
    </library>
  </component>
  <component name="masterDetails">
    <states>
      <state key="ArtifactsStructureConfigurable.UI">
        <UIState>
          <splitter-proportions>
            <SplitterProportionsDataImpl />
          </splitter-proportions>
          <settings />
        </UIState>
      </state>
      <state key="Copyright.UI">
        <UIState>
          <splitter-proportions>
            <SplitterProportionsDataImpl />
          </splitter-proportions>
        </UIState>
      </state>
      <state key="ProjectJDKs.UI">
        <UIState>
          <splitter-proportions>
            <SplitterProportionsDataImpl>
              <option name="proportions">
                <list>
                  <option value="0.2" />
                </list>
              </option>
            </SplitterProportionsDataImpl>
          </splitter-proportions>
          <last-edited>1.6</last-edited>
        </UIState>
      </state>
      <state key="ScopeChooserConfigurable.UI">
        <UIState>
          <splitter-proportions>
            <SplitterProportionsDataImpl />
          </splitter-proportions>
          <settings />
        </UIState>
      </state>
    </states>
  </component>
</project>